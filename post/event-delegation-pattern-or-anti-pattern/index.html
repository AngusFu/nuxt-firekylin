<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head>
    <title data-n-head="true">[译] 事件代理：模式 or 反模式？ | 文蔺的博客</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta data-n-head="true" name="description" content="文蔺的前端学习记录，国外技术文章翻译，个人学习心得等等这些都会记录在这里。"><meta data-n-head="true" name="keywords" content="翻译,设计模式"><meta data-n-head="true" name="description" content="事件代理：模式 or 反模式？"><link data-n-head="true" rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/static/0501d49c081ea86e209e.css">
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="wrapper"><nav id="sidebar" class="behavior_1"><div class="wrap"><div class="profile"><a href="/" class="nuxt-link-active"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a> <span>文蔺的博客</span></div> <ul class="buttons"><li><a href="/" title="主页" class="nuxt-link-active"><i class="iconfont icon-home"></i> <span> 主页</span></a></li><li><a href="/archives" title="归档"><i class="iconfont icon-archive"></i> <span> 归档</span></a></li><li><a href="/slides" title="Slides"><i class="iconfont icon-archive"></i> <span> Slides</span></a></li><li><a href="/about" title="关于"><i class="iconfont icon-user"></i> <span> 关于</span></a></li><li><a href="/link" title="关注"><i class="iconfont icon-link"></i> <span> 关注</span></a></li><li><a href="/collection" title="收藏"><i class="iconfont icon-archive"></i> <span> 收藏</span></a></li></ul></div> <ul class="buttons"><li><a href="https://github.com/AngusFu/" rel="nofollow" target="_blank" class="inline"><i title="GitHub" class="iconfont icon-github-v"></i></a> <!----> <!----> <a href="/atom.xml" target="_blank" class="inline"><i title="RSS" class="iconfont icon-rss-v"></i></a> <a href="/search" class="inline"><i title="Search" class="iconfont icon-search"></i></a></li></ul></nav> <div id="header"><div class="btn-bar"><i></i></div> <h1><a href="/" class="nuxt-link-active">文蔺的博客</a></h1> <a href="/about/" class="me"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a></div> <div id="sidebar-mask" style="display:none"></div> <div id="main" class="main"><div id="page-post"><article class="post detail"><div class="meta"><div class="date">2017-07-19</div></div> <h1 class="title">[译] 事件代理：模式 or 反模式？</h1> <div class="entry-content"><blockquote><p style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis">
          原文作者:
          <a target="_blank" href="https://www.sitepen.com/blog/author/nroberts/">@Neil Roberts</a> <br>原文地址:
          <a target="_blank" href="https://www.sitepen.com/blog/2017/07/11/event-delegation-pattern-or-anti-pattern/">https://www.sitepen.com/blog/2017/07/11/event-delegation-pattern-or-anti-pattern/</a> <br>译文地址:
          <a target="_blank" href="http://www.wemlion.com/post/event-delegation-pattern-or-anti-pattern">http://www.wemlion.com/post/event-delegation-pattern-or-anti-pattern</a> <br>本文由
          <a target="_blank" href="http://www.wemlion.com">文蔺</a> 翻译，转载请保留此声明。
          <br>著作权属于原作者，本译文仅用于学习、研究和交流目的，请勿用于商业目的。
        </p></blockquote> <p><img alt=""></p> <p>JavaScript 工具包（toolkit）和框架所做的大量工作，都集中于尝试修复、规范或优化浏览器的功能实现。此类工作需要做出许多假设，这些假设包括：问题是什么，开发人员将如何使用我们的工具，以及我们对未来的期望。</p> <p>但这些假设经常是错误的。更有甚者，在很长一段时间内，这些选择可能貌似正确，直至某天我们被问题反咬一口。在这个无知的幸福时期当中，我们的工具包可能变得相当受欢迎，并成为大型复杂代码库的重要组成部分。</p> <h2 id="-">事件冒泡与事件代理</h2> <p>事件冒泡允许源自子节点的事件向父级节点“冒泡”（bubble）。这种行为导致 JavaScript 开发者使用松散的设计模式来识别我们所关心的接收事件的节点 —— 通常使用 CSS 选择器 —— 同时将事件监听器添加到该节点的父级节点上。</p> <p>一旦这种模式进入工具包之中，设计 API 时须做出一些假设。在开始阶段，这些假设主要围绕性能与效率展开。</p> <p>事件代理（Event Delegation）是处理事件的实际方法之一。然而，这种方法论适用于所有项目吗？实际上，更好的问题可能是，每个工具包的所基于的假设是否与你的项目需求相符。要想知道某个 API 是否适合当下项目，就要了解这些工具是建立在哪些假设之上的，并且理解每个工具包如何解释它们。</p> <h2 id="-">假设</h2> <p>一起来看看，在思考如何有效管理 DOM 事件时可能会产生的一些假设。</p> <h3 id="-">本机事件注册机制太慢</h3> <p>在你能够提出 API 存在的继发原因之前，不要创建新的 API。随着浏览器厂商们对运行时的投入增加，你的功能实现总有一天会比原生实现慢。我所在的 SitePen 有一个项目依赖于数组拼接（splice）速度。我们发现，在某些情况下，手动操作索引和数组长度能够带来显著的性能提升。但我们无法定位到特定浏览器、浏览器版本或平台，因为无法进行运行时功能测试以确定我们的实现是否比原生 API 快。</p> <h3 id="-api-">新的原生 API 不会出现</h3> <p>保持谨慎，确保已收集到足够的信息，可以降级使用原生实现 —— 无论是已存在的，还是理想情况下可能存在的。这项工作的另一个名字叫“预防过时”（future proofing）。在某些情况下，你可能会使用必需参数超出绝对需要的 API，但如果它l能够保证轻松地过渡到更优秀的原生 API，那么完全可以如此。一个很好的例子是最终获得原生支持的 <code>querySelectorAll</code> API，之前许多开发人员假设这种事永远不会发生。</p> <h3 id="-">不常见用例没有性能损失</h3> <p>事件代理可能会以数种方式呈现。例如两种特殊情况：大量节点上的少量事件，以及少数节点上的大量事件。如果针对其中之一进行优化，则可能会为另一个带来明显的瓶颈。虽然使用事件代理可能只需要向单个节点添加一个事件侦听器，但识别触发回调的节点的复杂方法对性能的影响可能不成比例。快速触发大量事件（例如鼠标移动或滚动事件）正是使用事件代理的场景。</p> <h3 id="-">条件与背景</h3> <p>在考虑事件代理时，很容易认为我们只需要关心用户交互。这可能导致我们假设节点始终是文档的一部分，然后开始思考，为何不在 document 对象上添加单个事件处理程序呢？<strong>DOM 事件并非总是用户交互的结果 —— 我们也有人为事件、自定义事件以及加载事件等。</strong>如果想要监听的节点不在文档中，而监听器却绑定在 document 对象上，我们永远得不到通知。如果在 API 中无法区别监听器是添加到 document 上，抑或是添加到我们所传递的参数上，则能够理解为什么会出现这种情况。</p> <h3 id="-">抽象</h3> <p>如果一个工具包提供一个仅用于支持代理的事件处理 API —— 需要父级节点和标识子节点的选择器 —— 则无法将事件监听器直接添加到某个节点。即使是使用 CSS 选择器，也引入了更高级的功能，可以轻松地使用另一种选择器语法或简单函数。</p> <h3 id="-">不会发生副作用</h3> <p>如上所述，DOM 事件冒泡是事件代理模式存在的前提。但是了解完整规范所涉及的内容之后，你会发现，事件冒泡是可以取消的。你的实现可能会将 stopPropagation 方法为空函数的自定义事件传递给回调函数；或者，你可能只会记录问题，并限制事件代理 API 的使用。这两种方法都有问题，但是如果你打算像为 document 对象事件处理程序那样工作，添加大量可取消的事件层可能放大副作用。</p> <h3 id="-">不受时间影响</h3> <p>一旦代码编写完成，很可能就会弃而不顾。但浏览器正在以我们无法想象、预测的方式向前发展，我们在编写代码时所做的假设可能会被证明是错误的，尽管我们尽了最大的努力。</p> <h2 id="-">总结</h2> <p>为什么要在项目中使用事件代理？</p> <ul><li><p>原生实现太慢了吗？对现代浏览器来说不太可能。</p></li> <li><p>是否有更好的 API 来执行事件代理？目前还没有 —— 如果你需要事件代理，这是一个很好的模式。</p></li> <li><p>该工具包的性能优化是否符合项目需求？如果它专注于特殊情况，可能不会。</p></li> <li><p>工具包的实现中有没有什么不适用于你的项目的内容？阅读文档，这些通常都会标出。</p></li> <li><p>是否有副作用？遇到错误前你可能不会发现这一点，所以要特别注意。</p></li></ul> <p>人们在不了解创作假设的情况下，所有设计模式都有成为反模式的风险，所以对项目中使用的任何新工具都应当回答同样的问题。如果你所做的似乎是在抄近路，要特别小心。谨慎、多加思考，才能使项目发光。</p></div></article> <nav class="pagination"><a href="/post/font-display" title="[译] font-display 的使用" class="prev">« [译] font-display 的使用</a> <a href="/post/functional-programming" title="函数响应式编程 —— RxJS 简介" class="next">函数响应式编程 —— RxJS 简介 »</a></nav></div> <footer id="footer" class="inner">
      © 2022 -  文蔺的博客
      
        <span> - </span> <a href="/" class="nuxt-link-active">www.wemlion.com</a> <br>
      Powered by <a target="_blank" href="https://nuxtjs.org">Nuxt.js</a> & <a target="_blank" rel="nofollow" href="https://firekylin.org" class="external">FireKylin</a></footer></div></div></div></div><script>window.__NUXT__={layout:"default",data:[{}],error:null,serverRendered:!0}</script><script src="/static/c418fb652629ac1ad5ca.js" defer></script><script src="/static/9c582e181db5eb0d4a33.js" defer></script><script src="/static/a04af2434d342797c405.js" defer></script><script src="/static/a9e13b4b84fcd888d410.js" defer></script><script src="/static/0329710550037b626a84.js" defer></script>
  </body>
</html>
