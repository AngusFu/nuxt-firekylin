<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head>
    <title data-n-head="true">[译] 浏览器中的 ES6 module 实现 | 文蔺的博客</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta data-n-head="true" name="description" content="文蔺的前端学习记录，国外技术文章翻译，个人学习心得等等这些都会记录在这里。"><meta data-n-head="true" name="keywords" content="翻译,ES6"><meta data-n-head="true" name="description" content="浏览器中的 ES6 module 实现"><link data-n-head="true" rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/static/0501d49c081ea86e209e.css">
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="wrapper"><nav id="sidebar" class="behavior_1"><div class="wrap"><div class="profile"><a href="/" class="nuxt-link-active"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a> <span>文蔺的博客</span></div> <ul class="buttons"><li><a href="/" title="主页" class="nuxt-link-active"><i class="iconfont icon-home"></i> <span> 主页</span></a></li><li><a href="/archives" title="归档"><i class="iconfont icon-archive"></i> <span> 归档</span></a></li><li><a href="/slides" title="Slides"><i class="iconfont icon-archive"></i> <span> Slides</span></a></li><li><a href="/about" title="关于"><i class="iconfont icon-user"></i> <span> 关于</span></a></li><li><a href="/link" title="关注"><i class="iconfont icon-link"></i> <span> 关注</span></a></li><li><a href="/collection" title="收藏"><i class="iconfont icon-archive"></i> <span> 收藏</span></a></li></ul></div> <ul class="buttons"><li><a href="https://github.com/AngusFu/" rel="nofollow" target="_blank" class="inline"><i title="GitHub" class="iconfont icon-github-v"></i></a> <!----> <!----> <a href="/atom.xml" target="_blank" class="inline"><i title="RSS" class="iconfont icon-rss-v"></i></a> <a href="/search" class="inline"><i title="Search" class="iconfont icon-search"></i></a></li></ul></nav> <div id="header"><div class="btn-bar"><i></i></div> <h1><a href="/" class="nuxt-link-active">文蔺的博客</a></h1> <a href="/about/" class="me"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a></div> <div id="sidebar-mask" style="display:none"></div> <div id="main" class="main"><div id="page-post"><article class="post detail"><div class="meta"><div class="date">2017-05-06</div></div> <h1 class="title">[译] 浏览器中的 ES6 module 实现</h1> <div class="entry-content"><blockquote><p style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis">
          原文作者:
          <a target="_blank" href="https://jakearchibald.com/">@Jake Archibald</a> <br>原文地址:
          <a target="_blank" href="https://jakearchibald.com/2017/es-modules-in-browsers/">https://jakearchibald.com/2017/es-modules-in-browsers/</a> <br>译文地址:
          <a target="_blank" href="http://www.wemlion.com/post/es-modules-in-browsers">http://www.wemlion.com/post/es-modules-in-browsers</a> <br>本文由
          <a target="_blank" href="http://www.wemlion.com">文蔺</a> 翻译，转载请保留此声明。
          <br>著作权属于原作者，本译文仅用于学习、研究和交流目的，请勿用于商业目的。
        </p></blockquote> <p>ES6 的模块特性（module） 开始在浏览器端实现啦！一切正在路上...</p> <table><thead><tr><th>浏览器</th> <th>备注</th></tr></thead> <tbody><tr><td>Safari 10.1</td> <td>(无)</td></tr> <tr><td>Chrome Canary 60</td> <td>打开 <code>chrome:flags</code> 启用“实验性网络平台功能”</td></tr> <tr><td>Firefox 54</td> <td>打开 <code>about:config</code> 启用 <code>dom.moduleScripts.enabled</code></td></tr> <tr><td>Edge 15</td> <td>打开 <code>about:flags</code> 启用“实验性 JavaScript 功能”</td></tr></tbody></table> <pre><code class="hljs lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>></span><span class="javascript">
  <span class="hljs-keyword">import</span> {addTextToBody} <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils.js'</span>;

  addTextToBody(<span class="hljs-string">'Modules are pretty cool.'</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span></code></pre><pre><code class="hljs lang-javascript"><span class="hljs-comment">// utils.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTextToBody</span>(<span class="hljs-params">text</span>) </span>{
  <span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);
  div.textContent = text;
  <span class="hljs-built_in">document</span>.body.appendChild(div);
}</code></pre><p><strong><a href="https://cdn.rawgit.com/jakearchibald/a298d5af601982c338186cd355e624a8/raw/aaa2cbee9a5810d14b01ae965e52ecb9b2965a44/" target="_blank">Live demo</a></strong>。</p> <p>只需为 <code>script</code> 元素添加 <code>type=module</code> 属性，浏览器就会把该元素对应的内联脚本或外部脚本当成 ECMAScript 模块进行处理。</p> <p>目前已经有一些 <a href="https://ponyfoo.com/articles/es6-modules-in-depth" target="_blank">很棒的关于 ECMAScript 模块的文章</a>了，不过我还是想分享一些和浏览器相关的东西，它们都是我在测试代码、阅读规范的过程中学习到的。</p> <h2 id="-import-">尚未得到支持的 import 路径符号</h2> <pre><code class="hljs lang-javascript"><span class="hljs-comment">// 支持</span>
<span class="hljs-keyword">import</span> {foo} <span class="hljs-keyword">from</span> <span class="hljs-string">'https://jakearchibald.com/utils/bar.js'</span>;
<span class="hljs-keyword">import</span> {foo} <span class="hljs-keyword">from</span> <span class="hljs-string">'/utils/bar.js'</span>;
<span class="hljs-keyword">import</span> {foo} <span class="hljs-keyword">from</span> <span class="hljs-string">'./bar.js'</span>;
<span class="hljs-keyword">import</span> {foo} <span class="hljs-keyword">from</span> <span class="hljs-string">'../bar.js'</span>;

<span class="hljs-comment">// 不支持</span>
<span class="hljs-keyword">import</span> {foo} <span class="hljs-keyword">from</span> <span class="hljs-string">'bar.js'</span>;
<span class="hljs-keyword">import</span> {foo} <span class="hljs-keyword">from</span> <span class="hljs-string">'utils/bar.js'</span>;</code></pre><p>有效的路径符号应当符合以下条件规则之一：</p> <ul><li>完整的非相对路径。这样在将其传给<code>new URL(moduleSpecifier)</code>的时候才不会报错。</li> <li>以 <code>/</code> 开头。</li> <li>以 <code>./</code> 开头。</li> <li>以 <code>../</code> 开头。</li></ul> <p>其他形式的符号被保留下来，未来将用于其他功能（如引入[import]内置模块）。</p> <h2 id="-nomodule-">使用 <code>nomodule</code> 属性向后兼容</h2> <pre><code class="hljs lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"module.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"fallback.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span></code></pre><p><strong><a href="https://cdn.rawgit.com/jakearchibald/6110fb6df717ebca44c2e40814cc12af/raw/7fc79ed89199c2512a4579c9a3ba19f72c219bd8/" target="_blank">Live demo</a></strong>。</p> <p>支持 <code>type=module</code> 的浏览器将会忽略带有 <code>nomodule</code> 属性的 <code>script</code> 标签。这意味着我们可以为支持模块的浏览器提供模块形式的代码，同时为那些不支持模块的浏览器提供降级处理。</p> <h3 id="-issue">浏览器 issue</h3> <ul><li>Firefox 暂不支持 <code>nomodule</code> (<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1330900" target="_blank">issue</a>)。</li> <li>Edge 暂不支持 <code>nomodule</code> (<a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10525830/" target="_blank">issue</a>)。</li> <li>Safari 10.1 暂不支持 <code>nomodule</code>，但在最新的技术预览版中已经解决了此问题。对于 10.1 来说，有一个<a href="https://gist.github.com/samthor/64b114e4a4f539915a95b91ffd340acc" target="_blank">相当棒的解决方案</a>。</li></ul> <h2 id="-">默认延迟执行</h2> <pre><code class="hljs lang-html"><span class="hljs-comment">&lt;!-- 这个脚本会在… --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- …这个脚本之后、… --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"2.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- …这个脚本之前执行。 --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"3.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span></code></pre><p><strong><a href="https://cdn.rawgit.com/jakearchibald/d6808ea2665f8b3994380160dc2c0bc1/raw/c0a194aa70dda1339c960c6f05b2e16988ee66ac/" target="_blank">Live demo</a></strong>。脚本执行顺序为 <code>2.js</code>, <code>1.js</code>, <code>3.js</code>。</p> <p>获取脚本会导致 HTML parser 阻塞，这简直太太太太恶心了。对正常的脚本，我们可以使用 <code>defer</code> 属性来防止阻塞，脚本将延迟至文档解析完毕后执行，同时保持与其他使用 <code>defer</code> 的脚本之间的执行顺序。模块脚本的默认行为与 <code>defer</code> 相同 —— 无法使模块脚本阻塞 HTML parser。</p> <p>模块脚本与使用 <code>defer</code> 的正常脚本使用相同的执行队列。</p> <h2 id="-">内联脚本同样延迟</h2> <pre><code class="hljs lang-html"><span class="hljs-comment">&lt;!-- 这个脚本会在… --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>></span><span class="actionscript">
  addTextToBody(<span class="hljs-string">"Inline module executed"</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- …这个脚本… --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- …以及这个脚本之后、… --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span>></span><span class="actionscript">
  addTextToBody(<span class="hljs-string">"Inline script executed"</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- …这个脚本之前执行。 --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"2.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span></code></pre><p><strong><a href="https://cdn.rawgit.com/jakearchibald/7026f72c0675898196f7669699e3231e/raw/fc7521aabd9485f30dbd5189b407313cd350cf2b/" target="_blank">Live demo</a></strong>。执行顺序依次为 <code>1.js</code>、内联脚本、内联模块、<code>2.js</code>。</p> <p>正常的内联脚本会忽略 <code>defer</code> 属性，而内联模块则总是延迟执行，无论是否引入其他内容。</p> <h2 id="-async-"><code>async</code> 对内联、外部模块同样适用</h2> <pre><code class="hljs lang-html"><span class="hljs-comment">&lt;!-- 脚本将会在其引入的模块加载完成后立即执行 --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>></span><span class="javascript">
  <span class="hljs-keyword">import</span> {addTextToBody} <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils.js'</span>;

  addTextToBody(<span class="hljs-string">'Inline module executed.'</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- 脚本及其引入的模块加载完成后立即执行 --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span></code></pre><p><strong><a href="https://module-script-tests-rgjnxtrtqq.now.sh/async" target="_blank">Live demo</a></strong>。先完成加载的脚本先执行。</p> <p>与正常脚本相同，带有 <code>async</code> 属性的脚本在下载时不会阻塞 HTML parser，一旦加载完毕，立即执行。不同的是，<code>async</code> 对内联模块也同样适用。</p> <p>使用 <code>async</code> 时，脚本的执行顺序可能会和它们在 DOM 中出现的顺序不尽相同。</p> <h3 id="-issue">浏览器 issue</h3> <ul><li>Firefox 不支持内联模块使用 <code>async</code>(<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1361369" target="_blank">issue</a>)。</li></ul> <h2 id="-">模块只执行一次</h2> <pre><code class="hljs lang-html"><span class="hljs-comment">&lt;!-- 1.js 只执行一次 --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>></span><span class="actionscript">
  <span class="hljs-meta"><span class="hljs-meta-keyword">import</span> "./1.js";</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- 普通脚本会执行多次 --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"2.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"2.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span></code></pre><p><strong><a href="https://cdn.rawgit.com/jakearchibald/f7f6d37ef1b4d8a4f908f3e80d50f4fe/raw/1fcedde007a2b90049a7ea438781aebe69e22762/" target="_blank">Live demo</a></strong>。</p> <p>引入同一个模块多次的时候，模块只会执行一次。这对 HTML 中的模块脚本同样适用 —— 在同一个页面中，URL 相同的模块只会执行一次。</p> <h3 id="-issue">浏览器 issue</h3> <ul><li>Edge 会执行多次 (<a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11865922/" target="_blank">issue</a>)。</li></ul> <h2 id="-cors">总是使用 CORS</h2> <pre><code class="hljs lang-html"><span class="hljs-comment">&lt;!-- 模块不会执行，因其未通过 CORS 检查 --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://….now.sh/no-cors"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- 模块不会执行，因其引入的脚本未通过 CORS 检查 --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>></span><span class="actionscript">
  <span class="hljs-meta"><span class="hljs-meta-keyword">import</span> 'https://….now.sh/no-cors';</span>

  addTextToBody(<span class="hljs-string">"This will not execute."</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- CORS 检查通过，模块将会执行 --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://….now.sh/cors"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span></code></pre><p><strong><a href="https://cdn.rawgit.com/jakearchibald/2b8d4bc7624ca6a2c7f3c35f6e17fe2d/raw/fe04e60b0b7021f261e79b8ef28b0ccd132c1585/" target="_blank">Live demo</a></strong>。</p> <p>与正常脚本不同，模块脚本（及其引入的脚本）是通过 CORS 获取的。这意味着，跨域模块脚本必须返回类似 <code>Access-Control-Allow-Origin: *</code> 这样的有效的响应头。</p> <h3 id="-issue">浏览器 issue</h3> <ul><li>Firefox 无法加载 demo 页面(<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1361373" target="_blank">issue</a>)。</li> <li>Edge 加载了没有 CORS 响应头的模块(<a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11865934/" target="_blank">issue</a>)。</li></ul> <h2 id="-">不携带凭证信息</h2> <pre><code class="hljs lang-html"><span class="hljs-comment">&lt;!-- 请求脚本时会携带相关凭证 (如 cookie) --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- 不会携带相关凭证 --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- 会携带相关凭证 --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">crossorigin</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.js?"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- 不会携带相关凭证 --></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">crossorigin</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://other-origin/1.js"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span>

<span class="hljs-comment">&lt;!-- 会携带相关凭证--></span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"use-credentials"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://other-origin/1.js?"</span>></span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span></code></pre><p><strong><a href="https://module-script-tests-zoelmqooyv.now.sh/cookie-page" target="_blank">Live demo</a></strong>。</p> <p>在请求同源的情况下，多数基于 CORS 的 API 都会发送凭证信息（credentials，如 Cookie）。但 <code>fetch()</code> 和模块脚本恰恰例外 —— 除非手动声明，否则是不会发送相关凭证的。</p> <p>对于一个同源的模块脚本，可以为其添加 <code>crossorigin</code> 属性（这看起来挺怪的，我已经在规范中提出这个<a href="https://github.com/whatwg/html/issues/2557" target="_blank">问题</a>了），这样在请求时就可以携带相关凭证了。如果你还想将凭证发给其他域，请使用 <code>crossorigin="use-credentials"</code>。需要注意的是，接收凭证的域必须返回 <code>Access-Control-Allow-Credentials: true</code> 的响应头。</p> <p>此外，还有一个与“模块只会执行一次”这条规则相关的问题。浏览器是通过 URL 来区别不同模块的，所以如果你先请求了一个模块而不携带任何凭证，紧接着又携带凭证信息去请求该模块，那么第二次得到的依然是不携带凭证的请求所返回的模块。这正是我在上面代码中的 URL 后面加上“?”的原因。</p> <h3 id="-issue">浏览器 issue</h3> <ul><li>请求同源模块时，Chrome 会携带凭证信息(<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=717525" target="_blank">issue</a>)。</li> <li>即使添加了 <code>crossorigin</code> 属性，Safari 在请求同源脚本时也不会携带凭证信息(<a href="https://bugs.webkit.org/show_bug.cgi?id=171550" target="_blank">issue</a>)。</li> <li>Edge 则完全弄反了。请求同源模块时，Edge 默认会发送凭证信息，但如果手动添加了 <code>crossorigin</code> 属性，则又不会携带 (<a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11865956/" target="_blank">issue</a>)。</li></ul> <p>Firefox 是唯一正确实现这一点的浏览器 —— 好样的！</p> <h2 id="mime-types">Mime-types</h2> <p>不同于普通脚本，对于通过 module 引入的脚本，服务器必须返回<a href="https://html.spec.whatwg.org/multipage/scripting.html#javascript-mime-type" target="_blank">合法的 MIME type</a>，否则脚本将不会执行。</p> <p><strong><a href="https://module-script-tests-zoelmqooyv.now.sh/mime" target="_blank">Live demo</a></strong>。</p> <h3 id="-issue">浏览器 issue</h3> <ul><li>Edge 仍将执行 MIME type 非法的脚本(<a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11865977/" target="_blank">issue</a>)。</li></ul> <hr> <p>以上就是我目前所学习到的所有内容。浏览器开始支持 ES6 模块，简直太开心啦~</p></div></article> <nav class="pagination"><a href="/post/opensearch" title="Chrome 中的 “Tab to Search” 与 Open Search" class="prev">« Chrome 中的 “Tab to Search” 与 Open Search</a> <a href="/post/prepack" title="Facebook 开源代码优化工具 Prepack" class="next">Facebook 开源代码优化工具 Prepack »</a></nav></div> <footer id="footer" class="inner">
      © 2022 -  文蔺的博客
      
        <span> - </span> <a href="/" class="nuxt-link-active">www.wemlion.com</a> <br>
      Powered by <a target="_blank" href="https://nuxtjs.org">Nuxt.js</a> & <a target="_blank" rel="nofollow" href="https://firekylin.org" class="external">FireKylin</a></footer></div></div></div></div><script>window.__NUXT__={layout:"default",data:[{}],error:null,serverRendered:!0}</script><script src="/static/c418fb652629ac1ad5ca.js" defer></script><script src="/static/e6ad6525cacc961838da.js" defer></script><script src="/static/a04af2434d342797c405.js" defer></script><script src="/static/a9e13b4b84fcd888d410.js" defer></script><script src="/static/0329710550037b626a84.js" defer></script>
  </body>
</html>
