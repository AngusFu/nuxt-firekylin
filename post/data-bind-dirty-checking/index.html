<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head>
    <title data-n-head="true">[译] 手把手教你写一个 Javascript 框架：数据绑定 | 文蔺的博客</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta data-n-head="true" name="description" content="文蔺的前端学习记录，国外技术文章翻译，个人学习心得等等这些都会记录在这里。"><meta data-n-head="true" name="keywords" content="翻译,ES6,数据绑定"><meta data-n-head="true" name="description" content="手把手教你写一个 Javascript 框架：数据绑定"><link data-n-head="true" rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/static/0501d49c081ea86e209e.css">
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="wrapper"><nav id="sidebar" class="behavior_1"><div class="wrap"><div class="profile"><a href="/" class="nuxt-link-active"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a> <span>文蔺的博客</span></div> <ul class="buttons"><li><a href="/" title="主页" class="nuxt-link-active"><i class="iconfont icon-home"></i> <span> 主页</span></a></li><li><a href="/archives" title="归档"><i class="iconfont icon-archive"></i> <span> 归档</span></a></li><li><a href="/slides" title="Slides"><i class="iconfont icon-archive"></i> <span> Slides</span></a></li><li><a href="/about" title="关于"><i class="iconfont icon-user"></i> <span> 关于</span></a></li><li><a href="/link" title="关注"><i class="iconfont icon-link"></i> <span> 关注</span></a></li><li><a href="/collection" title="收藏"><i class="iconfont icon-archive"></i> <span> 收藏</span></a></li></ul></div> <ul class="buttons"><li><a href="https://github.com/AngusFu/" rel="nofollow" target="_blank" class="inline"><i title="GitHub" class="iconfont icon-github-v"></i></a> <!----> <!----> <a href="/atom.xml" target="_blank" class="inline"><i title="RSS" class="iconfont icon-rss-v"></i></a> <a href="/search" class="inline"><i title="Search" class="iconfont icon-search"></i></a></li></ul></nav> <div id="header"><div class="btn-bar"><i></i></div> <h1><a href="/" class="nuxt-link-active">文蔺的博客</a></h1> <a href="/about/" class="me"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a></div> <div id="sidebar-mask" style="display:none"></div> <div id="main" class="main"><div id="page-post"><article class="post detail"><div class="meta"><div class="date">2016-11-14</div></div> <h1 class="title">[译] 手把手教你写一个 Javascript 框架：数据绑定</h1> <div class="entry-content"><blockquote><p style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis">
          原文作者:
          <a target="_blank" href="https://blog.risingstack.com/author/bertalan/">Bertalan Miklos</a> <br>原文地址:
          <a target="_blank" href="https://blog.risingstack.com/writing-a-javascript-framework-data-binding-dirty-checking/">https://blog.risingstack.com/writing-a-javascript-framework-data-binding-dirty-checking/</a> <br>译文地址:
          <a target="_blank" href="http://www.wemlion.com/post/data-bind-dirty-checking">http://www.wemlion.com/post/data-bind-dirty-checking</a> <br>本文由
          <a target="_blank" href="http://www.wemlion.com">文蔺</a> 翻译，转载请保留此声明。
          <br>著作权属于原作者，本译文仅用于学习、研究和交流目的，请勿用于商业目的。
        </p></blockquote> <p><strong>本文是“编写 JavaScript 框架”系列的第四章。本章我将解释脏检查和基于getter/setter 访问器的数据绑定技术，并指出它们各自的优缺点。</strong></p> <p>本系列主要是如何开发一个开源的客户端框架，框架名为 NX。我将在本系列中分享框架编写过程中如何克服遇到的主要困难。对 NX 感兴趣的朋友可以点击 NX 项目<a href="http://nx-framework.com/" target="_blank">主页</a>查看。</p> <p>本系列章节如下：</p> <ul><li><a href="/post/nx-project-structure/">项目结构（Project structuring）</a></li> <li><a href="/post/execution-timing/">执行调度（Execution timing）</a></li> <li><a href="/post/sandbox-code-evaluation/">沙箱求值（Sandboxed code evaluation）</a></li> <li>数据绑定简介(本文)</li> <li><a href="/post/es6-proxy-data-binding/">ES6 Proxy 实现数据绑定</a></li> <li>自定义元素</li> <li>客户端路由</li></ul> <h2 id="-">数据绑定简介</h2> <blockquote><p>数据绑定是将数据源与数据提供者、消费者绑定并在它们之间保持同步的一种基本技术。</p></blockquote> <p>上面这个基本定义指出了数据绑定技术的通用构建模块。</p> <ul><li>定义数据提供者、消费者</li> <li>定义哪些变化触发数据同步</li> <li>数据提供者监听变化的方式</li> <li>发送变化时运行的同步函数 —— 下文会将该函数称作 <code>handler()</code></li></ul> <p>不同数据绑定技术采用不同方式实现以上几步。接下来几个小节介绍其中两种技术，即脏检查、getter/setter 访问器方法。介绍完它们后我将简要讨论它们各自的优缺点。</p> <h3 id="-">脏检查</h3> <p>脏检查可能是最广为人知的数据绑定方法。它是一种不错的传统选择，因其概念简单，无需复杂的语言特性支持。</p> <h3 id="-">脏检查语法</h3> <p>定义数据提供者和消费者无需任何特殊语法，仅靠普通 JavaScript 对象即可。</p> <pre><code class="hljs lang-javascript"><span class="hljs-keyword">const</span> provider = {
  <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello World'</span>
}
<span class="hljs-keyword">const</span> consumer = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>)</code></pre><p>数据同步通常由提供者属性变化触发。那些需要对变化进行观察的属性，必须明确映射到各自的<code>handler()</code>函数。</p> <pre><code class="hljs lang-javascript">observe(provider, <span class="hljs-string">'message'</span>, message => {
  consumer.innerHTML = message
})</code></pre><p><code>observe()</code> 函数仅仅保存了 <code>(provider, property) -> handler</code> 映射，留作后用。</p> <pre><code class="hljs lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span> (<span class="hljs-params">provider, prop, handler</span>) </span>{
  provider._handlers[prop] = handler
}</code></pre><p>这样一来就可以定义数据提供者、消费者，为属性变化注册<code>handler()</code>函数。公有 API 部分已经完成，下面要完成的是内部实现。</p> <h3 id="-">监听变化</h3> <p>脏检查之所以“脏”是有原因的。它依赖周期性检查，而非直接监听属性变化。这种周期性检查通常称作 digest cycle。在一个 digest cycle 内，遍历由<code>observe()</code>所添加的每一个 <code>(provider, property) -> handler</code> 入口，并检查属性自上一次遍历以来是否发生了变化。若发生变化，则运行<code>handler()</code>函数。简单实现如下：</p> <pre><code class="hljs lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">digest</span> (<span class="hljs-params"></span>) </span>{
  providers.forEach(digestProvider)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">digestProvider</span> (<span class="hljs-params">provider</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> provider._handlers) {
    <span class="hljs-keyword">if</span> (provider._prevValues[prop] !== provider[prop]) {
      provider._prevValues[prop] = provider[prop]
      handler(provider[prop])
    }
  }
}</code></pre><p><code>digest()</code> 函数需要不时运行，以保障状态同步。</p> <h2 id="getter-setter-">getter/setter 访问器方法</h2> <p>getter/setter 访问器方法是当前的主流趋势，其支持广泛程度稍低，因为需要用到 ES5 getter/setter 功能。但这种方法之优雅足以弥补这个问题。</p> <h3 id="-">访问器语法</h3> <p>定义数据提供者需要一些特殊语法。普通提供者对象需要传给<code>observable()</code>函数，转换为可观察对象。</p> <pre><code class="hljs lang-javascript"><span class="hljs-keyword">const</span> provider = observable({
  <span class="hljs-attr">greeting</span>: <span class="hljs-string">'Hello'</span>,
  <span class="hljs-attr">subject</span>: <span class="hljs-string">'World'</span>
})
<span class="hljs-keyword">const</span> consumer = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>)</code></pre><p>这完全可以弥补简单的 <code>handler()</code> 映射语法。在脏检查中，我们必须像下面这样，为每一个观察属性明确进行定义：</p> <pre><code class="hljs lang-javascript">observe(provider, <span class="hljs-string">'greeting'</span>, greeting => {
  consumer.innerHTML = greeting + <span class="hljs-string">' '</span> + provider.subject
})

observe(provider, <span class="hljs-string">'subject'</span>, subject => {
  consumer.innerHTML = provider.greeting + <span class="hljs-string">' '</span> + subject
})</code></pre><p>又笨又长。访问器技术可以在 <code>handler()</code> 函数中自动检测用到的提供者属性，这样就可以简化以上代码。</p> <pre><code class="hljs lang-javascript">observe(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {
  consumer.innerHTML = provider.greeting + <span class="hljs-string">' '</span> + provider.subject
})</code></pre><p><code>observe()</code> 的实现与脏检查并不相同。我们仅仅需要执行传入的 <code>handler()</code>，并在其执行期间将其标记为当前活动函数。</p> <pre><code class="hljs lang-javascript"><span class="hljs-keyword">let</span> activeHandler

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span>(<span class="hljs-params">handler</span>) </span>{
  activeHandler = handler
  handler()
  activeHandler = <span class="hljs-literal">undefined</span>
}</code></pre><p>我们利用 JavaScript 单线程特点，采用单一的<code>activehandler</code>变量来记录当前运行的<code>handler()</code> 函数。</p> <h3 id="-">监听变化</h3> <p>“访问器技术”终于闪亮登场。借助于 getter/setter 访问器在背后的强力支持，数据提供者 provider 的能力大大增强。基本的思想是，拦截 provider 的属性获取、设置操作。</p> <ul><li><p>get：如果存在正在运行的<code>activeHandler</code>，则保存<code>(provider, property) -> activeHandler</code>映射，稍后使用。</p></li> <li><p>set：运行所有 <code>(provide, property)</code> 对应的 <code>handler()</code>函数。</p></li></ul> <p><img alt="The accessor data binding technique."></p> <p>下面是监听单个属性变化的简单实现：</p> <pre><code class="hljs lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observableProp</span> (<span class="hljs-params">provider, prop</span>) </span>{
  <span class="hljs-keyword">const</span> value = provider[prop]
  <span class="hljs-built_in">Object</span>.defineProperty(provider, prop, {
    get () {
      <span class="hljs-keyword">if</span> (activeHandler) {
        provider._handlers[prop] = activeHandler
      }
      <span class="hljs-keyword">return</span> value
    },
    set (newValue) {
      value = newValue
      <span class="hljs-keyword">const</span> handler = obj._handlers[prop]
      <span class="hljs-keyword">if</span> (handler) {
        activeHandler = handler
        handler()
        activeHandler = <span class="hljs-literal">undefined</span>
      }
    }
  })
}</code></pre><p>上一节提到的<code>observable()</code>函数会递归遍历 provider 的属性，并使用 <code>observableProp()</code> 函数将它们统统转换为可观察对象。</p> <pre><code class="hljs lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observable</span> (<span class="hljs-params">provider</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> provider) {
    observableProp(provider, prop)
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> provider[prop] === <span class="hljs-string">'object'</span>) {
      observable(provider[prop])
    }
  }
}</code></pre><p>这只是一个简单实现，但用来对比两种技术已足够。</p> <h2 id="-">两种技术对比</h2> <p>本节将简要指出脏检查和访问器两种技术各自的优缺点。</p> <h3 id="-">语法形式</h3> <p>脏检查无需定义提供者、消费者，但将 <code>(provider, property)</code> 和 <code>handler()</code> 进行映射的方式笨拙又不灵活。</p> <p>访问器技术需要使用 <code>observable()</code> 函数对提供者进行封装，不过自动进行 <code>handler()</code> 映射弥补了不足。对于使用数据绑定的大型项目来说，访问器技术是必备特性。</p> <h3 id="-">性能</h3> <p>脏检查早就因其性能表现臭名昭著。每次 digest cycle 中，需要对每个 <code>(provider, property) -> handler</code> 入口进行数次检查。此外，即便应用处于闲置状态也必须保持运转，因为它并不值得属性何时发生变化。</p> <p>访问器方法更快一些，但在一些大型可观察对象面前，性能也可能发生退化。使用访问器替换提供者的所有属性，通常是过重了。一种解决办法是在必要时动态建立 getter/setter，而不是一次性提前完成。此外，还有一种简单方法是使用一个 <code>noObserve()</code> 函数包装不需要的属性，告诉 <code>observable()</code> 不要理会这些。但这会引入额外的语法。</p> <h3 id="-">灵活性</h3> <p>脏检查天生就能和扩展属性（动态添加的）以及访问器属性一起工作。</p> <p>访问器技术在这方面有个弱点。初始化 getter/setter 时，扩展属性并不包含在内。比如对数组来说，这就会导致问题，但也能通过手动调用 <code>observableProp()</code> 来解决。访问器属性也无法支持，因为访问器属性无法再包装一次。一种常见的解决办法是使用 <code>computed()</code> 函数替代 getter。不过这会引入更多自定义语法。</p> <h3 id="-">时间控制</h3> <p>脏检查给我们的自由并不多，因为我们无从得知属性实际发生变化的时机。<code>handler()</code> 函数只能通过不时运行 <code>digest()</code> 循环而异步执行。</p> <p>使用访问器技术，getter/setter 是同步触发的，因此就有了选择上的自由。我们可以决定是否立即执行 <code>handler()</code>，或者分批异步执行。前者保证了可预见性，后者则可以通过去重提升性能。</p> <h2 id="-">关于下一章</h2> <p>下一章我将介绍 <a href="https://github.com/RisingStack/nx-observe" target="_blank">nx-observe</a> 数据绑定工具，阐述如何用 ES6 Proxy 替代  ES5 getters/setters，以弥补访问器技术的多数不足之处。</p> <h2 id="-">写在最后</h2> <p>如果对 NX 框架感兴趣，请访问 <a href="http://nx-framework.com/" target="_blank">主页</a>。胆大的读者还可以在Github 上查看 <a href="https://github.com/RisingStack/nx-framework" target="_blank">NX 源码</a> 和 <a href="https://github.com/RisingStack/nx-observe" target="_blank">nx-observe 源码</a>。</p> <p>希望你喜欢这篇文章。下一章我们将讨论 <a href="https://blog.risingstack.com/writing-a-javascript-framework-sandboxed-code-evaluation/" target="_blank">沙箱求值（Sandboxed code evaluation）</a>。</p></div></article> <nav class="pagination"><a href="/post/execution-timing" title="[译] 手把手教你写一个 Javascript 框架：执行调度" class="prev">« [译] 手把手教你写一个 Javascript 框架：执行调度</a> <a href="/post/es6-proxy-data-binding" title="[译] 手把手教你写一个 Javascript 框架：使用 ES6 Proxy 实现数据绑定" class="next">[译] 手把手教你写一个 Javascript 框架：使用 ES6 Proxy 实现数据绑定 »</a></nav></div> <footer id="footer" class="inner">
      © 2022 -  文蔺的博客
      
        <span> - </span> <a href="/" class="nuxt-link-active">www.wemlion.com</a> <br>
      Powered by <a target="_blank" href="https://nuxtjs.org">Nuxt.js</a> & <a target="_blank" rel="nofollow" href="https://firekylin.org" class="external">FireKylin</a></footer></div></div></div></div><script>window.__NUXT__={layout:"default",data:[{}],error:null,serverRendered:!0}</script><script src="/static/c418fb652629ac1ad5ca.js" defer></script><script src="/static/bee5e558ba4ae0647c90.js" defer></script><script src="/static/a04af2434d342797c405.js" defer></script><script src="/static/a9e13b4b84fcd888d410.js" defer></script><script src="/static/0329710550037b626a84.js" defer></script>
  </body>
</html>
