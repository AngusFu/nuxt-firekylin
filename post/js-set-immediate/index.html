<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head>
    <title data-n-head="true">关于 setImmediate | 文蔺的博客</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta data-n-head="true" name="description" content="文蔺的前端学习记录，国外技术文章翻译，个人学习心得等等这些都会记录在这里。"><meta data-n-head="true" name="keywords" content="原创,JavaScript"><meta data-n-head="true" name="description" content="关于 setImmediate"><link data-n-head="true" rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/static/0501d49c081ea86e209e.css">
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="wrapper"><nav id="sidebar" class="behavior_1"><div class="wrap"><div class="profile"><a href="/" class="nuxt-link-active"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a> <span>文蔺的博客</span></div> <ul class="buttons"><li><a href="/" title="主页" class="nuxt-link-active"><i class="iconfont icon-home"></i> <span> 主页</span></a></li><li><a href="/archives" title="归档"><i class="iconfont icon-archive"></i> <span> 归档</span></a></li><li><a href="/slides" title="Slides"><i class="iconfont icon-archive"></i> <span> Slides</span></a></li><li><a href="/about" title="关于"><i class="iconfont icon-user"></i> <span> 关于</span></a></li><li><a href="/link" title="关注"><i class="iconfont icon-link"></i> <span> 关注</span></a></li><li><a href="/collection" title="收藏"><i class="iconfont icon-archive"></i> <span> 收藏</span></a></li></ul></div> <ul class="buttons"><li><a href="https://github.com/AngusFu/" rel="nofollow" target="_blank" class="inline"><i title="GitHub" class="iconfont icon-github-v"></i></a> <!----> <!----> <a href="/atom.xml" target="_blank" class="inline"><i title="RSS" class="iconfont icon-rss-v"></i></a> <a href="/search" class="inline"><i title="Search" class="iconfont icon-search"></i></a></li></ul></nav> <div id="header"><div class="btn-bar"><i></i></div> <h1><a href="/" class="nuxt-link-active">文蔺的博客</a></h1> <a href="/about/" class="me"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a></div> <div id="sidebar-mask" style="display:none"></div> <div id="main" class="main"><div id="page-post"><article class="post detail"><div class="meta"><div class="date">2016-10-27</div></div> <h1 class="title">关于 setImmediate</h1> <div class="entry-content"><!----> <h2 id="w3c-draft">W3C Draft</h2> <ul><li><a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html" target="_blank">文档地址</a></li></ul> <p>题目叫 “Efficient Script Yielding”，一份 2011 年的 “Editor's Draft”，从题目就能看出用途。建议有时间读一遍，超级短。摘要就一句话：</p> <blockquote><p>This specification defines an interface for web applications to flush the browser event queue and receive an immediate callback.
本说明文档定义了一个用于刷新浏览器事件队列、接收即时回调的 Web 应用接口。</p></blockquote> <h2 id="mdn">MDN</h2> <ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate" target="_blank">文档地址</a></li></ul> <p>MDN 的文档没得说。遇到问题去查查肯定不会害你，有时候运气好，还能读到翻译过来的中文版：</p> <blockquote><p>This method is used to break up long running operations and run a callback function immediately after the browser has completed other operations such as events and display updates.
该方法用来把一些需要长时间运行的操作放在一个回调函数里,在浏览器完成后面的其他语句后,就立刻执行这个回调函数。</p></blockquote> <p>但同时，文档提到， <strong>只有 IE 10+ 和 Node.js 0.10+ 实现了该方法</strong>。setImmediate 受到了 Gecko 和 Webkit 的 “resistance”（抵制）。建议跟着去看看热闹。</p> <p>MDN 文档中提到了三种模拟 setImmediate 的方式：<code>postMessage</code>、<code>MessageChannel</code>、<code>setTimeout(fn, 0)</code>。</p> <h2 id="setimmediate-polyfill">setImmediate polyfill</h2> <ul><li><a href="https://github.com/YuzuJS/setImmediate" target="_blank">源码</a></li></ul> <p>对于 Node 0.9 之前的，使用 <code>process.nextTick</code> 模拟；对于非 IE 10 的现代浏览器，使用 <code>postMessage</code>；对 Web Worker，使用 <code>MessageChannel</code>（这个之后需要关注下）；对 IE 6–8，向 html 中插入新的 script 标签，在 <code>onreadystatechange</code> 事件中执行回调；其他浏览器，统一使用 <code>setTimeout(fn, 0)</code> 的形式。</p> <pre><code class="hljs lang-javascript"><span class="hljs-comment">// Don't get fooled by e.g. browserify environments.</span>
<span class="hljs-keyword">if</span> ({}.toString.call(global.process) === <span class="hljs-string">"[object process]"</span>) {
    <span class="hljs-comment">// For Node.js before 0.9</span>
    installNextTickImplementation();

} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (canUsePostMessage()) {
    <span class="hljs-comment">// For non-IE10 modern browsers</span>
    installPostMessageImplementation();

} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (global.MessageChannel) {
    <span class="hljs-comment">// For web workers, where supported</span>
    installMessageChannelImplementation();

} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (doc && <span class="hljs-string">"onreadystatechange"</span> <span class="hljs-keyword">in</span> doc.createElement(<span class="hljs-string">"script"</span>)) {
    <span class="hljs-comment">// For IE 6–8</span>
    installReadyStateChangeImplementation();

} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// For older browsers</span>
    installSetTimeoutImplementation();
}</code></pre><h2 id="nicholas-c-zakas-">Nicholas C. Zakas 的文章</h2> <ul><li><a href="https://www.nczonline.net/blog/2011/09/19/script-yielding-with-setimmediate/" target="_blank">文章地址</a></li></ul> <p>文章很短，但讲得还挺仔细的。作者提到了两点好处：</p> <ul><li>可以直接在 UI 队列清空后直接插入 JS 任务；</li> <li>延迟更短，不必等待下一次 timer tick</li></ul> <h2 id="edge-demo">Edge Demo</h2> <ul><li><a href="https://msedgeportal.trafficmanager.net/en-us/microsoft-edge/testdrive/demos/setImmediateSorting/" target="_blank">Demo 地址</a></li></ul> <p>通过 250 个数的排序，来对比处理效率。基本原理是，排序时将每一步的交换操作放在回调中，对比排序完成的效率。一共有四种：</p> <ul><li><code>setTimeout(fn, 15)</code></li> <li><code>setTimeout(fn, 4)</code></li> <li><code>PostMessage</code></li> <li><code>setImmediate</code></li></ul> <p>关于前两种的时间间隔问题，建议直接取读 demo 底部的说明。已经很详细了。</p> <h2 id="stackoverflow">Stackoverflow</h2> <ul><li><p><a href="http://stackoverflow.com/questions/15349733/setimmediate-vs-nexttick" target="_blank">setImmediate vs. nextTick</a></p></li> <li><p><a href="http://stackoverflow.com/questions/17502948/nexttick-vs-setimmediate-visual-explanation" target="_blank">nextTick vs setImmediate, visual explanation</a></p></li></ul> <h2 id="-">题外话</h2> <ul><li><p>以前竟然不知道 setTimeout 也能接收第三个第四个参数的。<code>setTimeout((a, b) => a + b, 0, 22, 33)</code>。</p></li> <li><p><code>!(x > 9)</code> 和 <code>x &lt;= 9</code> 可不一定完全等价，前者在不确定 <code>x</code> 的类型时，特别有用，不用额外判断 undefined。</p></li></ul></div></article> <nav class="pagination"><a href="/post/20161027-reading" title="2016 年 10 月 27 日阅读笔记" class="prev">« 2016 年 10 月 27 日阅读笔记</a> <a href="/post/front-end-interview-algo-questions" title="关于前端常见算法面试题的一些思考" class="next">关于前端常见算法面试题的一些思考 »</a></nav></div> <footer id="footer" class="inner">
      © 2022 -  文蔺的博客
      
        <span> - </span> <a href="/" class="nuxt-link-active">www.wemlion.com</a> <br>
      Powered by <a target="_blank" href="https://nuxtjs.org">Nuxt.js</a> & <a target="_blank" rel="nofollow" href="https://firekylin.org" class="external">FireKylin</a></footer></div></div></div></div><script>window.__NUXT__={layout:"default",data:[{}],error:null,serverRendered:!0}</script><script src="/static/c418fb652629ac1ad5ca.js" defer></script><script src="/static/e853a1a2faa446f72043.js" defer></script><script src="/static/a04af2434d342797c405.js" defer></script><script src="/static/a9e13b4b84fcd888d410.js" defer></script><script src="/static/0329710550037b626a84.js" defer></script>
  </body>
</html>
