<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head>
    <title data-n-head="true">Facebook 开源代码优化工具 Prepack | 文蔺的博客</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta data-n-head="true" name="description" content="文蔺的前端学习记录，国外技术文章翻译，个人学习心得等等这些都会记录在这里。"><meta data-n-head="true" name="keywords" content="JavaScript"><meta data-n-head="true" name="description" content="Facebook 开源代码优化工具 Prepack"><link data-n-head="true" rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/static/0501d49c081ea86e209e.css">
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="wrapper"><nav id="sidebar" class="behavior_1"><div class="wrap"><div class="profile"><a href="/" class="nuxt-link-active"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a> <span>文蔺的博客</span></div> <ul class="buttons"><li><a href="/" title="主页" class="nuxt-link-active"><i class="iconfont icon-home"></i> <span> 主页</span></a></li><li><a href="/archives" title="归档"><i class="iconfont icon-archive"></i> <span> 归档</span></a></li><li><a href="/slides" title="Slides"><i class="iconfont icon-archive"></i> <span> Slides</span></a></li><li><a href="/about" title="关于"><i class="iconfont icon-user"></i> <span> 关于</span></a></li><li><a href="/link" title="关注"><i class="iconfont icon-link"></i> <span> 关注</span></a></li><li><a href="/collection" title="收藏"><i class="iconfont icon-archive"></i> <span> 收藏</span></a></li></ul></div> <ul class="buttons"><li><a href="https://github.com/AngusFu/" rel="nofollow" target="_blank" class="inline"><i title="GitHub" class="iconfont icon-github-v"></i></a> <!----> <!----> <a href="/atom.xml" target="_blank" class="inline"><i title="RSS" class="iconfont icon-rss-v"></i></a> <a href="/search" class="inline"><i title="Search" class="iconfont icon-search"></i></a></li></ul></nav> <div id="header"><div class="btn-bar"><i></i></div> <h1><a href="/" class="nuxt-link-active">文蔺的博客</a></h1> <a href="/about/" class="me"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a></div> <div id="sidebar-mask" style="display:none"></div> <div id="main" class="main"><div id="page-post"><article class="post detail"><div class="meta"><div class="date">2017-05-04</div></div> <h1 class="title">Facebook 开源代码优化工具 Prepack</h1> <div class="entry-content"><!----> <p>Fackbook 又搞了个大新闻！</p> <p>今天一早，朋友圈被一个名为 Prepack 的工具刷爆了。</p> <p>周刊君很好奇地看了下官网（<a href="https://prepack.io/" target="_blank">prepack.io</a>），这么厉害的工具，有必要第一时间向大家介绍一下（还能不能好好过个青年节了）。</p> <p>看 “Prepack” 这个名字就能大概知道，它的作用，肯定是在发布前（“pre”）对代码动了些什么手脚。官网介绍 Prepack 是“一个使 JavaScript 跑得更快的工具”。那么它到底做了些什么厉害的事情呢？</p> <p>根据官网首页信息，Prepack “能够消除那些可以本可以在编译（compile）阶段完成的运行时计算”，将代码中的某些部分替换为一系列赋值语句，这样一来就可以省去很多中间计算和对象的分配工作。</p> <h3 id="-">官方示例</h3> <p>下面是 Prepack 官网给出的一个例子：</p> <pre><code class="hljs lang-javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-number">42</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">'_'</span> + x.toString()[<span class="hljs-number">0</span>].toLowerCase();
    <span class="hljs-keyword">var</span> y = <span class="hljs-built_in">parseInt</span>(x);
    self[name] = y ? y : x;
  });
})();</code></pre><p>经过 Prepack 的处理，上面这段代码变成了下面这样：</p> <pre><code class="hljs lang-javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  _a = <span class="hljs-string">"A"</span>;
  _b = <span class="hljs-string">"B"</span>;
  _4 = <span class="hljs-number">42</span>;
})();</code></pre><p>原来的 <code>.forEach</code> 调用没有了，一系列的中间转换过程也不见了。借用官网的说法，“多数的计算都在 Prepack 编译时进行了预初始化”。</p> <p>再举一个 Fibonacci 的例子：</p> <pre><code class="hljs lang-javascript"><span class="hljs-comment">// 处理前</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x &lt;= <span class="hljs-number">1</span> ? x : fibonacci(x - <span class="hljs-number">1</span>) + fibonacci(x - <span class="hljs-number">2</span>);
  }
  global.x = fibonacci(<span class="hljs-number">23</span>);
})();

<span class="hljs-comment">// 处理后</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  x = <span class="hljs-number">28657</span>;
})();</code></pre><h3 id="-">工作机制</h3> <p>据官网介绍，Prepack 的实现依赖以下几个方面：</p> <h4 id="1-ast-">1. AST（抽象语法树）</h4> <p>Prepack 是在 AST 这一层级对代码进行操作的。通过 Babel 来解析源码，并生成优化后的代码。关于 Babel 与 AST，周刊君推荐两篇文章：</p> <ul><li><p>《<a href="https://mp.weixin.qq.com/s/fFQUBeg332gdU8yNddauxQ" target="_blank">Babel for ES6? And Beyond!</a>》</p></li> <li><p>《<a href="http://www.zcfy.cc/article/347" target="_blank">通过开发 Babel 插件理解抽象语法树（AST）</a>》</p></li></ul> <h4 id="2-concrete-execution-">2. 具体执行（Concrete Execution）</h4> <p>Prepack 的核心部分是“一个大致兼容 ECMAScript 5 的编译器”（an almost ECMAScript 5 compatible interpreter），而这个编译器是通过 JavaScript 实现的。这个编译器可以追踪、撤销包括对象变化在内的所有的操作。这样一来就能进行推理性的优化（speculative optimizations）。</p> <h4 id="3-symbolic-execution-">3. 符号执行（Symbolic Execution）</h4> <p>除了计算具体值，Prepack 的编译器还可以操作抽象值，而这些抽象值通常都来自于代码与环境的交互。如 <code>Date.now</code> 所返回的就是抽象值。此外，根据官网首页的描述，还可以通过 <code>__abstract()</code> 这样的辅助工具函数，手动插入抽象值。Prepack 会追踪发生在抽象值之上的操作，如果有分支情况，则会对所有可能性进行探查。</p> <p>官网介绍说，“因此，Prepack 为 JavaScript 实现了一套符号执行引擎”。为了方便大家理解，周刊君特地引用了<a href="https://zh.wikipedia.org/wiki/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C" target="_blank">维基百科</a>上的一段话：</p> <blockquote><p>符号执行 （Symbolic Execution）是一种程序分析技术。其可以通过分析程序来得到让特定代码区域执行的输入。使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。</p></blockquote> <h4 id="4-abstract-interpretation-">4. 抽象解释（Abstract Interpretation）</h4> <p>官网的描述有点复杂。关于抽象解释，请移步<a href="https://en.wikipedia.org/wiki/Abstract_interpretation" target="_blank">维基百科</a>。有兴趣的可以去官网阅读原文。</p> <h4 id="5-heap-serialization-">5. 堆序列化（Heap Serialization）</h4> <p>初始化阶段结束时，Prepack 会捕获最终的堆。按顺序遍历堆，生成新的代码，创建、链接堆中的可及对象。</p> <p>如前所述，堆中的一些值可能是对抽象值进行计算的结果。Prepack 将会根据这些值生成执行计算的代码，其计算过程与源程序相同。</p> <h3 id="-">环境很重要！</h3> <p>需要注意的是，Prepack 并未完整模拟浏览器、Node 环境，Prepack 对 <code>document</code> 和 <code>window</code> 并没有多少了解。对这样一些属性求值的时候，将会得到 <code>undefined</code>。如果需要在这样一些地方使用 Prepack，必须通过一些工具函数实现。</p> <h3 id="-">如何尝鲜</h3> <pre><code class="hljs lang-bash"><span class="hljs-comment"># 安装</span>
npm install -g prepack

<span class="hljs-comment"># 处理文件，并打印到控制台</span>
prepack script.js

<span class="hljs-comment"># 处理文件，并输出到新文件</span>
prepack script.js --out script-processed.js</code></pre><p>除了上面的基本用法之外，还支持如 sourceMap 等更多选项。这里就不一一介绍了。</p> <h3 id="-">当前支持情况</h3> <p>此外，官方介绍称，<strong>“Prepack 目前仍处于早期开发阶段，尚未做好投入生产环境的准备”</strong>。不过，还是响应 Prepack 的号召吧，“try it out, give feedback, and help fix bugs”。</p> <p>想要进一步关于该项目的发展计划，可以访问官网首页的 <a href="https://prepack.io/" target="_blank">Roadmap</a> 部分。</p> <h3 id="-">相关技术</h3> <p>Closure Compiler 同样会对 JavaScript 代码进行优化。Prepack 比 Closure Compiler 走得更远的地方在于执行了初始化阶段的全局代码，展开循环、递归。官网的一个说法是，“Prepack 着眼于运行时性能，而 Closure Compiler 的重点在于代码体积”。</p></div></article> <nav class="pagination"><a href="/post/es-modules-in-browsers" title="[译] 浏览器中的 ES6 module 实现" class="prev">« [译] 浏览器中的 ES6 module 实现</a> <a href="/post/fun-hacks-faster-content" title="[译] 内容加速黑科技趣谈" class="next">[译] 内容加速黑科技趣谈 »</a></nav></div> <footer id="footer" class="inner">
      © 2022 -  文蔺的博客
      
        <span> - </span> <a href="/" class="nuxt-link-active">www.wemlion.com</a> <br>
      Powered by <a target="_blank" href="https://nuxtjs.org">Nuxt.js</a> & <a target="_blank" rel="nofollow" href="https://firekylin.org" class="external">FireKylin</a></footer></div></div></div></div><script>window.__NUXT__={layout:"default",data:[{}],error:null,serverRendered:!0}</script><script src="/static/c418fb652629ac1ad5ca.js" defer></script><script src="/static/574df3883a4e8d28f10e.js" defer></script><script src="/static/a04af2434d342797c405.js" defer></script><script src="/static/a9e13b4b84fcd888d410.js" defer></script><script src="/static/0329710550037b626a84.js" defer></script>
  </body>
</html>
