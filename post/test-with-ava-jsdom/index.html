<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head>
    <title data-n-head="true">使用 ava 和 jsdom 测试前端界面 | 文蔺的博客</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta data-n-head="true" name="description" content="文蔺的前端学习记录，国外技术文章翻译，个人学习心得等等这些都会记录在这里。"><meta data-n-head="true" name="keywords" content="原创,测试,JavaScript"><meta data-n-head="true" name="description" content="使用 ava 和 jsdom 测试前端界面"><link data-n-head="true" rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/static/0501d49c081ea86e209e.css">
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div class="wrapper"><nav id="sidebar" class="behavior_1"><div class="wrap"><div class="profile"><a href="/" class="nuxt-link-active"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a> <span>文蔺的博客</span></div> <ul class="buttons"><li><a href="/" title="主页" class="nuxt-link-active"><i class="iconfont icon-home"></i> <span> 主页</span></a></li><li><a href="/archives" title="归档"><i class="iconfont icon-archive"></i> <span> 归档</span></a></li><li><a href="/slides" title="Slides"><i class="iconfont icon-archive"></i> <span> Slides</span></a></li><li><a href="/about" title="关于"><i class="iconfont icon-user"></i> <span> 关于</span></a></li><li><a href="/link" title="关注"><i class="iconfont icon-link"></i> <span> 关注</span></a></li><li><a href="/collection" title="收藏"><i class="iconfont icon-archive"></i> <span> 收藏</span></a></li></ul></div> <ul class="buttons"><li><a href="https://github.com/AngusFu/" rel="nofollow" target="_blank" class="inline"><i title="GitHub" class="iconfont icon-github-v"></i></a> <!----> <!----> <a href="/atom.xml" target="_blank" class="inline"><i title="RSS" class="iconfont icon-rss-v"></i></a> <a href="/search" class="inline"><i title="Search" class="iconfont icon-search"></i></a></li></ul></nav> <div id="header"><div class="btn-bar"><i></i></div> <h1><a href="/" class="nuxt-link-active">文蔺的博客</a></h1> <a href="/about/" class="me"><img src="/imgs/avatar.jpg" alt="文蔺的博客"></a></div> <div id="sidebar-mask" style="display:none"></div> <div id="main" class="main"><div id="page-post"><article class="post detail"><div class="meta"><div class="date">2016-06-29</div></div> <h1 class="title">使用 ava 和 jsdom 测试前端界面</h1> <div class="entry-content"><!----> <h2 id="2016-09-03-">2016-09-03 更新</h2> <p>随着在工作学习中更多地接触、使用测试工具，发现自己在本文中的一些记录是不准确、不正确的。</p> <p>今天（九月三日）在家看了 NingJs 的直播，其中有一个分享是关于测试框架的，非常棒，之后有可能的话还是找来视频再学习下。</p> <p>是的，两个月前的理解，是很初级很浅陋的。</p> <p>继续学习，继续钻研吧。</p> <h2 id="-">交代前因</h2> <p>前些天接手了一个旧项目。幸好不是在原来的基础上做些修修改改的工作，可以算是开发新版的。</p> <p>把前面同事留下来的代码 down 下来，看了一下。总体还是挺好的。还有 <code>macha + chai</code> 的测试目录。</p> <p>我也是最近一段时间开始接触测试。很久之前看了阮大神写的 mocha 教程，不过也就看看，写写简单的 demo。</p> <p>前同事留下的测试，是基于浏览器的，主要还是功能测试。这里不详细说怎么在浏览器端使用 mocha 测试了。因为涉及到交互的反馈、追踪，所以采用的方式是，先用 iframe 加载待测页面，然后用 <code>contentWindow</code> 的方式拿到 iframe 的环境，再做一些操作。手动触发一些功能，然后再去判断相应的变化有没有发生。</p> <p>本地启动了一个 server，浏览器里跑了几遍测试。最后发现的问题是，有一个点击测试怎么都过不了。于是又开启了阅读代码的过程。</p> <p>最后发现了问题所在，页面使用的是自己封装的 tap 事件，整个事件系统也是对原生 Element 原型的拓展。可是怎么触发 tap 呢？前同事用了 <code>touchend</code>。可是并没有用啊， tap 事件的触发可是结合了从 touchstart 开启一系列事件参数的判断的。</p> <p>后来我就想，浏览器端功能测试，能不能也拿到命令行上面来呢？</p> <h2 id="-mocha-ava">从 mocha 转到 ava</h2> <p>正在此时，我想起了 <code>jsdom</code> 这个大神级作品。</p> <p>一开始打算用 <code>mocha + jsdom</code> 跑一把。<del>折腾了几次发现，mocha 这家伙不好适应异步的工作，这事情很难搞啊。</del></p> <p>可能要交代下我做了什么，嗯，我加载了一个 jquery 脚本，这样就得外部文件，于是就有异步场景了。试了好多遍，mocha 还是没能实现我的期望。（你也可以拿 mocha 试试看，多试几次，如果单纯靠那个 <code>done</code> 你就能成功，那么请私信我哟。）</p> <p>又想想白天乱逛 github 的时候，在一些个项目中看到了 <code>ava</code> 这个测试工具。搜索一番，据说正适用于异步场景。</p> <p>好，那就来试试看呗。前因交代清楚了，下面开始正式进入教程阶段。</p> <h2 id="-">测试场景</h2> <p>先说测试场景：页面上有一个红色背景的 div，通过原生的 addEventListener 绑定了 click 事件。点击之后，将背景色变换为绿色。就酱简单？对，主要就这个，一方面我是想测试下 jsdom 对事件系统和 css 解析的支持（手动触发事件，css 解析和值变化），一方面是想试试这种异步场景下怎么更好地测试。</p> <p>那些对测试脚本运行速度有非常严格要求的同学请想好了再往后看。因为根据我的经验，jsdom + ava 这俩组合起来，速度确实慢得不行。我还没仔细探究原因，但想来无非以下几点：</p> <ul><li><p>测试脚本要经过 babel 6 编译一遍，有耗时；</p></li> <li><p>jsdom 系统比较庞大，解析起来费劲；</p></li> <li><p>我使用了 jsdom 的 jQueryify 方法从外部加载了 jQuery 文件（但这方法确实给力）；</p></li> <li><p>ava 本身其他方面的问题；</p></li></ul> <p>暂且忍着点。</p> <p>核心 html 如下：</p> <pre><code class="hljs lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>></span><span class="css">
    <span class="hljs-selector-tag">div</span> {<span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>; <span class="hljs-attribute">background-color</span>: red;}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>></span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"div"</span>></span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>></span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"div"</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.style.backgroundColor = <span class="hljs-string">'green'</span>;
    };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>></span></code></pre><h2 id="-">测试工具安装</h2> <p>下面来谈工具的安装。</p> <p>首先安装 jsdom，这倒是很简单：</p> <pre><code class="hljs lang-bash">$ npm install --save jsdom</code></pre><p>接着安装 ava，最好先全局安装一遍：</p> <pre><code class="hljs lang-bash">
$ npm install -g ava

$ npm install --save ava</code></pre><p>然后为了方便使用 <code>npm test</code> 命令，执行下面的命令：</p> <pre><code class="hljs lang-bash">$ ava --init</code></pre><p>这一行的目的是将 ava 命令放到你的 <code>package.json</code> 中的 <code>scripts</code> 字段中，方便之后使用 <code>npm test</code> 直接开启跑测试。当然你也可以不管这一步，我就比较喜欢自己敲 <code>ava xx.js</code> 这样子。</p> <h2 id="-">编写测试</h2> <p>好了，环境安装完毕。下面来看脚本。</p> <pre><code class="hljs lang-javascript">
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">import</span> { jsdom } <span class="hljs-keyword">from</span> <span class="hljs-string">'jsdom'</span>;

<span class="hljs-keyword">import</span> test <span class="hljs-keyword">from</span> <span class="hljs-string">'ava'</span>;</code></pre><p>ava 在运行时会通过 babel 6 对测试脚本进行编译，因此完全可以自由发挥，generator、async & await 什么的都尽情地用吧。而且作者也是建议和支持这样做的，简单明了的测试脚本，重要性有时候可能和测试本身一样重要。</p> <p>引入 fs 是为了读取我们的 html 文件。</p> <p>关于 jsdom 的用法，更多的可以参考 <a href="https://github.com/tmpvar/jsdom" target="_blank">https://github.com/tmpvar/jsdom</a>，看项目的文档。这里我使用的是简单易懂的 <code>require('jsdom').jsdom</code> 形式，便于以同步的形式解析生成我们需要的 window 对象，如下：</p> <pre><code class="hljs lang-javascript">
<span class="hljs-keyword">var</span> <span class="hljs-built_in">window</span> = jsdom(fs.readFileSync(<span class="hljs-string">'./test.html'</span>)).defaultView;</code></pre><p>一个挺好用的方法是 <code>jsdom.jQueryify</code>，能向页面注入 jQuery。不过这是个异步的方法（废话），所以这里我使用了 Promise，也是为了方便之后使用 async & await 语法。</p> <pre><code class="hljs lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsdomTest</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{ 
        jsdom.jQueryify(<span class="hljs-built_in">window</span>, <span class="hljs-string">"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.js"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            resolve(<span class="hljs-built_in">window</span>.jQuery);
        });
    });
}</code></pre><p>ava 的测试用例写起来也挺简单，来看代码：</p> <pre><code class="hljs lang-javascript">
test(<span class="hljs-string">'点击测试'</span>, <span class="hljs-keyword">async</span> t => {
    <span class="hljs-keyword">var</span> $ = <span class="hljs-keyword">await</span> jsdomTest();

    <span class="hljs-keyword">var</span> $div = $(<span class="hljs-string">'#div'</span>);

    <span class="hljs-keyword">var</span> colorBeforeClick, colorAfterClick;

    <span class="hljs-built_in">console</span>.log(colorBeforeClick = $div.css(<span class="hljs-string">'background-color'</span>));

    $div.trigger(<span class="hljs-string">'click'</span>);

    <span class="hljs-built_in">console</span>.log(colorAfterClick = $div.css(<span class="hljs-string">'background-color'</span>));

    t.not(colorBeforeClick, colorAfterClick, <span class="hljs-string">'bgColor changed'</span>);
});</code></pre><p><code>test</code> 的第一个参数是测试用例的名称，第二个参数是一个函数，该函数会注入 <code>t</code> 对象。我们所有的断言都是通过这个注入的 <code>t</code> 进行的。</p> <p>友情提示：ava 的文档地址，<a href="https://github.com/avajs/ava" target="_blank">https://github.com/avajs/ava</a>，也有中文版，但是没更新同步，所以建议还是看英文，否则用了一些过时的 API，以后升级之后追悔莫及。</p> <p>来说上面的代码。首先我们使用的是 async & await 语法，整个看起来比回调函数嵌套要整洁许多，整个流程看起来也相对清楚。</p> <p>第一步是先等待 jQuery 注入成功，拿到 <code>$</code>。其实这一步可有可无，我纯粹是为了测试 jsdom API，并且懒得手动写 dispatch 事件的代码才这么干的。</p> <p>接下来就开始 DOM 查询，然后先获取 div 当前的背景色并打印出来。接着手动触发 click 事件，然后再次获取 div 的背景色并打印。最后将触发点击前后的两个颜色值拿来对比。</p> <p>依葫芦画瓢，差不多就这么搞定了。</p> <p>打开命令行，进入工作目录，然后开始测试：</p> <pre><code class="hljs lang-bash">
$  ava -v parallel.js</code></pre><p>相信我，<code>-v</code> 参数可以让你的命令行界面显得比较安静一些。</p> <p>如果你想要使用 <code>npm test</code> 这样的命令来测试，请进一步阅读文档进行相关配置（将上面的 <code>ava</code> 换成 <code>nom test</code>是没用的哦）。这里主要还是为了简便。</p> <h2 id="-">友情提示</h2> <p>友情提示第二波：会不会怀疑，触发点击事件之后，颜色立马就变了？不存在延迟、异步么？答案是 yes，真的不存在。假如你和我一样在这里犹豫了，那么说明存在这样两种可能性：</p> <ul><li><p>js 基础不够牢，对相关机制的了解还不透彻</p></li> <li><p>你被各种异步玩怕了（hybrid / RN 后遗症 ）</p></li></ul> <p>当时为了应对“潜在的异步”（啊我想到了迫害狂想症），我特意做了几百毫秒的 <code>setTimeout</code> 延时。结果呢，断言的谓词（not、same、notSame等等）各种正向、反向都试了一遍，测试永远通过。什么鬼？说好的良好的异步支持呢？后来再去看文档，发现人家写得清清楚楚：</p> <blockquote><p>You must define all tests synchronously. They can't be defined inside setTimeout, setImmediate, etc.
所有测试必须同步定义。不能放在 setTimeout、setImmediate 等方法里面。</p></blockquote> <p>所以，真的，认真读文档是很有必要的。</p> <p>真正遇到要延时的，怎么办？我想，Promise 会解救你的。</p> <h2 id="-">并行与串行</h2> <p>ava 声称是很高效的。通常情况下，同一个文件里测试都是并行的，并不一定按照顺序执行。</p> <p>还以上面的代码为例。为了测试一下，我选择了投机取巧。不是并行吗？那我就检测 jQuery 存不存在就不行了吗？因为我们的 <code>test</code> 中，是异步加载 jQuery 的。所以如果测试是并行的，那么不一定能够检测到 <code>window.$</code> 的存在。</p> <p>所以就有了 <a href="https://github.com/AngusFu/jsdom-ava-demo/blob/master/parallel.js" target="_blank">parallel.js</a> 这个文件。添加的测试用例如下：</p> <pre><code class="hljs lang-javascript">
test(<span class="hljs-string">'串行测试'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.$)
    t.true(!!<span class="hljs-built_in">window</span>.$, <span class="hljs-string">'串行失败'</span>);
});</code></pre><p>可是，如果我就要串行呢？</p> <p>还好作者也想到了这种情况。将所有的 <code>test</code> 改成 <code>test.serial</code> 即可（见 <a href="https://github.com/AngusFu/jsdom-ava-demo/blob/master/serial.js" target="_blank">serial.js</a>）。</p> <p>需要说明的是，所谓的串行执行，只是在同一个测试文件中存在，同时测试多个文件的时候，就总体而言仍然是并行的。</p> <h2 id="-">结尾</h2> <p>ava 还有很多的用法和需要注意的地方。最好的办法还是看文档，然后自己写 demo，反复领会，并应用在实际业务中。</p> <p>上面提到的内容，可能有不少错误。希望懂行的大神们能够提出来。</p> <p>突然想到古人说，“苟日新，又日新，日日新”。</p> <p>虽然经过今人考证，这也许只是类似甲骨文的祭祀记录的误读。但几千年来，这种“新”的精神始终在。</p> <p>程序世界里，变化更是无时不在。今天的工具，明天也许就会被淘汰。</p> <p>其实说到底，能够解决需求，能够方便高效使用的，才是最好的。</p> <p>向做出这些工具的大神们致敬。</p> <h2 id="-">更新</h2> <h3 id="a-">a 标签点击事件的坑</h3> <p><code>a</code> 标签的点击事件用了事件代理，然后通过手动触发无效。</p> <p>经测试，在浏览器也有这种问题。</p> <p>解决办法是直接使用 <code>$('a')[0].click()</code>，原生的 <code>click</code> 方法比较靠谱。</p> <p>参考： <a href="http://stackoverflow.com/questions/773639/how-can-i-simulate-an-anchor-click-via-jquery" target="_blank">http://stackoverflow.com/questions/773639/how-can-i-simulate-an-anchor-click-via-jquery</a></p></div></article> <nav class="pagination"><a href="/post/when-are-all-resources-all-loaded" title="判断资源并行加载完成的三种办法：计数、Promise及 $.Deferred" class="prev">« 判断资源并行加载完成的三种办法：计数、Promise及 $.Deferred</a> <a href="/post/notes-from-behind-the-firewall-the-state-of-web-design-in-china" title="[译] 防火墙背后的笔记：Web 设计在中国" class="next">[译] 防火墙背后的笔记：Web 设计在中国 »</a></nav></div> <footer id="footer" class="inner">
      © 2022 -  文蔺的博客
      
        <span> - </span> <a href="/" class="nuxt-link-active">www.wemlion.com</a> <br>
      Powered by <a target="_blank" href="https://nuxtjs.org">Nuxt.js</a> & <a target="_blank" rel="nofollow" href="https://firekylin.org" class="external">FireKylin</a></footer></div></div></div></div><script>window.__NUXT__={layout:"default",data:[{}],error:null,serverRendered:!0}</script><script src="/static/c418fb652629ac1ad5ca.js" defer></script><script src="/static/dc34483e958a35131db4.js" defer></script><script src="/static/a04af2434d342797c405.js" defer></script><script src="/static/a9e13b4b84fcd888d410.js" defer></script><script src="/static/0329710550037b626a84.js" defer></script>
  </body>
</html>
