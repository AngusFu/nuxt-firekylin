(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{222:function(t,l,n){"use strict";n.r(l);var v={computed:{data:function(){return{title:"[译] 手把手教你写一个 Javascript 框架：项目结构",description:"手把手教你写一个 Javascript 框架：项目结构",keywords:"翻译,ES6,JavaScript",pathname:"nx-project-structure",translation:{author:"Bertalan Miklos",social:"https://blog.risingstack.com/author/bertalan/",from:"https://blog.risingstack.com/writing-a-javascript-framework-project-structuring/"},create_time:"2016-11-20",prev:{title:"[译] CSS 方法论的选择",pathname:"when-to-use-which-css-methodology"},next:{title:"[译] 手把手教你写一个 Javascript 框架：沙箱求值",pathname:"sandbox-code-evaluation"}}}}},e=n(3),component=Object(e.a)(v,function(){var t=this,l=t.$createElement,n=t._self._c||l;return n("post",{attrs:{data:t.data}},[n("p",[t._v("过去几个月中，RisingStack 的 JavaScript 工程师 Bertalan Miklos 编写了新一代客户端框架 "),n("a",{attrs:{href:"http://nx-nxframework.rhcloud.com",target:"_blank"}},[t._v("NX")]),t._v("。Bertalan 将通过"),n("strong",[t._v("编写 JavaScript 框架")]),t._v("系列文章与我们分享他在编写框架过程中的收获：")]),t._v(" "),n("p",[n("strong",[t._v("本章将展示 NX 的项目结构，并讲述如何解决可扩展性、依赖注入以及私有变量等方面的一些困难。")])]),t._v(" "),n("p",[t._v("本系列章节如下：")]),t._v(" "),n("ol",[n("li",[t._v("项目结构（正是本文）")]),t._v(" "),n("li",[n("a",{attrs:{href:"/post/execution-timing/"}},[t._v("执行调度(Execution timing)")])]),t._v(" "),n("li",[n("a",{attrs:{href:"/post/sandbox-code-evaluation/"}},[t._v("沙箱求值")])]),t._v(" "),n("li",[n("a",{attrs:{href:"/post/data-bind-dirty-checking"}},[t._v("数据绑定简介")])]),t._v(" "),n("li",[n("a",{attrs:{href:"/post/es6-proxy-data-binding/"}},[t._v("ES6 Proxy 实现数据绑定")])]),t._v(" "),n("li",[t._v("自定义元素")]),t._v(" "),n("li",[t._v("客户端路由")])]),t._v(" "),n("h2",{attrs:{id:"-"}},[t._v("项目结构")]),t._v(" "),n("p",[t._v("没有放之四海而皆准的项目结构，但有一些基本准则。感兴趣的同学可以看下我们的 Node Hero 系列中的《"),n("a",{attrs:{href:"https://blog.risingstack.com/node-hero-node-js-project-structure-tutorial/",target:"_blank"}},[t._v("Node.js 项目结构教程")]),t._v(" 》这一章。")]),t._v(" "),n("h3",{attrs:{id:"nx-"}},[t._v("NX 框架概览")]),t._v(" "),n("p",[t._v("NX 的目标是成为一个开源社区驱动的易于扩展的项目。项目特点如下：")]),t._v(" "),n("ul",[n("li",[t._v("包含现代客户端框架必须的所有特性；")]),t._v(" "),n("li",[t._v("除 polyfill 外，没有任何外部依赖；")]),t._v(" "),n("li",[t._v("代码总量 3000 行；")]),t._v(" "),n("li",[t._v("没有代码多于 300 行的模块；")]),t._v(" "),n("li",[t._v("单个特性模块依赖不超过 3 个。")])]),t._v(" "),n("p",[t._v("项目各模块依赖关系如下图所示：")]),t._v(" "),n("p",[n("img",{directives:[{name:"lazy",rawName:"v-lazy",value:"https://p4.ssl.qhimg.com/t01c9e92dbaa52fc18f.png",expression:"`https://p4.ssl.qhimg.com/t01c9e92dbaa52fc18f.png`"}],attrs:{alt:"JavaScript Framework in post: The NX project structure"}})]),t._v(" "),n("p",[t._v("这种结构为典型框架开发难题提供了一种解决方案。")]),t._v(" "),n("ul",[n("li",[t._v("扩展性")]),t._v(" "),n("li",[t._v("依赖注入")]),t._v(" "),n("li",[t._v("私有变量")])]),t._v(" "),n("h3",{attrs:{id:"-"}},[t._v("可扩展性实现")]),t._v(" "),n("p",[t._v("社区驱动项目必须易于扩展。故项目的核心部分应当小巧，并拥有一个预定义的依赖处理系统。前者确保项目易于理解，后者则保证框架稳定。")]),t._v(" "),n("p",[t._v("本节先聚焦于实现小巧的内核。")]),t._v(" "),n("p",[t._v("现代框架应当拥有的主要特性就是创建自定义元素并将其应用于 DOM 的能力。NX 的核心只有一个 "),n("code",[t._v("component")]),t._v(" 函数，它的工作正在于此这个函数允许用户配置、注册一个新类型的元素。")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[t._v("component(config)\n  .register("),n("span",{staticClass:"hljs-string"},[t._v("'comp-name'")]),t._v(")")])]),n("p",[t._v("注册的 "),n("code",[t._v("comp-name")]),t._v(" 是空组件类型，可以按照预期在 DOM 中实例化。")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-html"},[n("span",{staticClass:"hljs-tag"},[t._v("<"),n("span",{staticClass:"hljs-name"},[t._v("comp-name")]),t._v(">")]),n("span",{staticClass:"hljs-tag"},[t._v("</"),n("span",{staticClass:"hljs-name"},[t._v("comp-name")]),t._v(">")])])]),n("p",[t._v("下一步是保证能使用新特性扩展组件。为保持简洁、可扩展，这些新特性不应该污染核心部分。这时候使用依赖注入就很方便了。")]),t._v(" "),n("h2",{attrs:{id:"-di-"}},[t._v("利用中间件实现依赖注入（DI）")]),t._v(" "),n("p",[t._v("如果你对依赖注入不太熟悉，建立先阅读这篇文章：《"),n("a",{attrs:{href:"https://blog.risingstack.com/dependency-injection-in-node-js",target:"_blank"}},[t._v("Dependency Injection in Node.js")]),t._v("》。")]),t._v(" "),n("blockquote",[n("p",[t._v("依赖注入是一种设计模式，在这种模式中，一个或多个依赖或服务被注入到或引用传递给一个独立对象。")])]),t._v(" "),n("p",[t._v("DI 解决了硬性依赖，却引入了新问题。使用者需要知道如何配置、注入依赖。大多客户端框架都将这些工作交给 DI 容器，帮助开发者完成。")]),t._v(" "),n("blockquote",[n("p",[t._v("DI 容器指的是知道如何实例化、配置对象的对象。")])]),t._v(" "),n("p",[t._v("另外一种方式则是中间件 DI 模式，这在服务端得到广泛应用（如 Express、Koa 等）。其中的奥秘在于，所有可注入的依赖（中间件）拥有相同的接口，以相同方式注入。这种方法则无需 DI 容器。")]),t._v(" "),n("p",[t._v("为保持简洁，我决定采用中间件模式。若你曾使用过 Express，以下代码自然不会陌生：")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[t._v("component()\n  .use(paint) "),n("span",{staticClass:"hljs-comment"},[t._v("// inject paint middleware")]),t._v("\n  .use(resize) "),n("span",{staticClass:"hljs-comment"},[t._v("// inject resize middleware")]),t._v("\n  .register("),n("span",{staticClass:"hljs-string"},[t._v("'comp-name'")]),t._v(")\n\n"),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("paint")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("elem, state, next")]),t._v(") ")]),t._v("{\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// elem is the component instance, set it up or extend it here")]),t._v("\n  elem.style.color = "),n("span",{staticClass:"hljs-string"},[t._v("'red'")]),t._v("\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// then call next to run the next middleware (resize)")]),t._v("\n  next()\n}\n\n"),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("resize")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("elem, state, next")]),t._v(") ")]),t._v("{\n  elem.style.width = "),n("span",{staticClass:"hljs-string"},[t._v("'100 px'")]),t._v("\n  next()\n}")])]),n("p",[t._v("中间件在新的组件实例插入 DOM 时执行，通常会给实例扩展一些新特性。如若不同库扩展相同对象，则将导致名称冲突。暴露私有变量会加剧问题，并可能被其他人意外利用。")]),t._v(" "),n("p",[t._v("公开 API 小巧玲珑，其余部分隐身不见，正是避免问题的优秀方案。")]),t._v(" "),n("h3",{attrs:{id:"-"}},[t._v("处理私有变量")]),t._v(" "),n("p",[t._v("JavaScript 中需要通过函数作用域来实现私有变量。需要使用跨作用域私有变量时，人们习惯使用"),n("code",[t._v("_")]),t._v("前缀来标志，并将其公开暴露。这可以避免意外使用，但无法解决命名冲突。更好的办法是使用  ES6 的 "),n("code",[t._v("Symbol")]),t._v(" 基本数据类型。")]),t._v(" "),n("blockquote",[n("p",[t._v("Symbol 是一种唯一的、不可变的数据类型，可用作对象属性标识符。")])]),t._v(" "),n("p",[t._v("下面的代码展示了 symbol 的实际使用：")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" color = "),n("span",{staticClass:"hljs-built_in"},[t._v("Symbol")]),t._v("()\n\n"),n("span",{staticClass:"hljs-comment"},[t._v("// a middleware")]),t._v("\n"),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("colorize")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("elem, state, next")]),t._v(") ")]),t._v("{\n  elem[color] = "),n("span",{staticClass:"hljs-string"},[t._v("'red'")]),t._v("\n  next()\n}")])]),n("p",[t._v("这样一来，通过 "),n("code",[t._v("color")]),t._v(" symbol （以及元素 elem）就能获取 "),n("code",[t._v("red")]),t._v("。"),n("code",[t._v("red")]),t._v(" 的私有程度，可由 "),n("code",[t._v("color")]),t._v(" symbol 暴露的不同程度控制。合理数量的私有变量，通过中心存储读取，是一种优雅的解决方案。")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-comment"},[t._v("// symbols module")]),t._v("\nexports.private = {\n  "),n("span",{staticClass:"hljs-attr"},[t._v("color")]),t._v(": "),n("span",{staticClass:"hljs-built_in"},[t._v("Symbol")]),t._v("("),n("span",{staticClass:"hljs-string"},[t._v("'color from colorize'")]),t._v(")\n}\nexports.public = {}")])]),n("p",[n("code",[t._v("index.js")]),t._v(" 如下：")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-comment"},[t._v("// main module")]),t._v("\n"),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" symbols = "),n("span",{staticClass:"hljs-built_in"},[t._v("require")]),t._v("("),n("span",{staticClass:"hljs-string"},[t._v("'./symbols'")]),t._v(")\nexports.symbols = symbols.public")])]),n("p",[t._v("在项目内部，所有模块都可访问 symbol 存储对象，但私有部分不会对外暴露。公有部分则可用于对外部开发者暴露一些低层次特性。这就避免了意外使用，因为开发者需要明确引入需要使用的 symbol。此外，symbol 引用也不会像字符串一样产出冲突，是故不会产生命名冲突。")]),t._v(" "),n("p",[t._v("以下几点概括了不同场景下的用法：")]),t._v(" "),n("p",[n("strong",[t._v("1. 公有变量")])]),t._v(" "),n("p",[t._v("正常使用.")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("elem, state, next")]),t._v(") ")]),t._v("{\n  elem.publicText = "),n("span",{staticClass:"hljs-string"},[t._v("'Hello World!'")]),t._v("\n  next()\n}")])]),n("p",[n("strong",[t._v("2. 私有变量")])]),t._v(" "),n("p",[t._v("项目私有的跨作用域变量，应当在私有 symbol 对象中加入一个 symbol key。")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-comment"},[t._v("// symbols module")]),t._v("\nexports.private = {\n  "),n("span",{staticClass:"hljs-attr"},[t._v("text")]),t._v(": "),n("span",{staticClass:"hljs-built_in"},[t._v("Symbol")]),t._v("("),n("span",{staticClass:"hljs-string"},[t._v("'private text'")]),t._v(")\n}\nexports.public = {}")])]),n("p",[t._v("并在需要的地方引入。")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" private = "),n("span",{staticClass:"hljs-built_in"},[t._v("require")]),t._v("("),n("span",{staticClass:"hljs-string"},[t._v("'symbols'")]),t._v(").private\n\n"),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("elem, state, next")]),t._v(") ")]),t._v("{\n  elem[private.text] = "),n("span",{staticClass:"hljs-string"},[t._v("'Hello World!'")]),t._v("\n  next()\n}")])]),n("p",[n("strong",[t._v("3. 半私有变量")])]),t._v(" "),n("p",[t._v("低层次 API 的变量，应当在公有 symbol 对象中加入一个 symbol key。")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-comment"},[t._v("// symbols module")]),t._v("\nexports.private = {\n  "),n("span",{staticClass:"hljs-attr"},[t._v("text")]),t._v(": "),n("span",{staticClass:"hljs-built_in"},[t._v("Symbol")]),t._v("("),n("span",{staticClass:"hljs-string"},[t._v("'private text'")]),t._v(")\n}\nexports.public = {\n  "),n("span",{staticClass:"hljs-attr"},[t._v("text")]),t._v(": "),n("span",{staticClass:"hljs-built_in"},[t._v("Symbol")]),t._v("("),n("span",{staticClass:"hljs-string"},[t._v("'exposed text'")]),t._v(")\n}")])]),n("p",[t._v("并在需要的地方引入。")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" exposed = "),n("span",{staticClass:"hljs-built_in"},[t._v("require")]),t._v("("),n("span",{staticClass:"hljs-string"},[t._v("'symbols'")]),t._v(").public\n\n"),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("elem, state, next")]),t._v(") ")]),t._v("{\n  elem[exposed.text] = "),n("span",{staticClass:"hljs-string"},[t._v("'Hello World!'")]),t._v("\n  next()\n}")])]),n("h3",{attrs:{id:"-"}},[t._v("写在最后")]),t._v(" "),n("p",[t._v("如果对 NX 框架感兴趣，请访问 "),n("a",{attrs:{href:"http://nx-framework.com/",target:"_blank"}},[t._v("主页")]),t._v("。胆大的读者还可以在 Github 上查看 "),n("a",{attrs:{href:"https://github.com/RisingStack/nx-framework",target:"_blank"}},[t._v("NX 源码")]),t._v(" 和 "),n("a",{attrs:{href:"https://github.com/RisingStack/nx-observe",target:"_blank"}},[t._v("nx-observe 源码")]),t._v("。")]),t._v(" "),n("p",[t._v("希望你喜欢这篇文章。下一章我们将讨论执行调度。")])])},[],!1,null,null,null);l.default=component.exports}}]);