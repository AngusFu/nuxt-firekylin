(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{170:function(e,t,n){"use strict";n.r(t);var r={computed:{data:function(){return{title:"react-native 开发 App 手记",description:"react-native 开发 App 手记",keywords:"原创,react-native,开发心得",pathname:"app-with-react-native",translation:null,create_time:"2016-04-22",prev:{title:"[译] No WebSockets Over HTTP2",pathname:"no-websockets-over-http2"},next:{title:"近来在Firefox上遇到的一些坑",pathname:"problems-with-firefox"}}}}},v=n(3),component=Object(v.a)(r,function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("post",{attrs:{data:e.data}},[n("p",[e._v("做了一个月的 "),n("code",[e._v("RN")]),e._v("。")]),e._v(" "),n("p",[e._v("遇到一些问题，陆续记录下来。一些关于组件上的问题不细说了。")]),e._v(" "),n("h2",{attrs:{id:"android-"}},[e._v("Android 下的键盘事件监听")]),e._v(" "),n("p",[e._v("一直想找安卓下面的键盘事件，可是官方文档（0.22）压根就没提这档子事啊。唯一稍微有点眉目的，就是关于"),n("a",{attrs:{href:"http://reactnative.cn/docs/0.22/native-modules-android.html#%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%E5%88%B0javascript",target:"_blank"}},[e._v("原生模块")]),e._v("这里。")]),e._v(" "),n("p",[e._v("后来看到了 "),n("a",{attrs:{href:"https://github.com/Andr3wHur5t/react-native-keyboard-spacer/blob/master/KeyboardSpacer.js",target:"_blank"}},[e._v("react-native-keyboard-spacer")]),e._v("  这个组件的写法，很傻很天真的以为是需要使用什么 "),n("code",[e._v("java")]),e._v(" 或 "),n("code",[e._v("OC")]),e._v(" 的支持。")]),e._v(" "),n("p",[e._v("于是我决定去看看源码，找到所有含有 "),n("code",[e._v("keyboard")]),e._v(" 的 "),n("code",[e._v("java")]),e._v(" 文件。这么一找，还真找到了。")]),e._v(" "),n("pre",[n("code",{staticClass:"hljs lang-java"},[e._v("\n"),n("span",{staticClass:"hljs-keyword"},[e._v("if")]),e._v(" (mKeyboardHeight != heightDiff && heightDiff > mMinKeyboardHeightDetected) {\n    "),n("span",{staticClass:"hljs-comment"},[e._v("// keyboard is now showing, or the keyboard height has changed")]),e._v("\n    mKeyboardHeight = heightDiff;\n    WritableMap params = Arguments.createMap();\n    WritableMap coordinates = Arguments.createMap();\n    coordinates.putDouble("),n("span",{staticClass:"hljs-string"},[e._v('"screenY"')]),e._v(", PixelUtil.toDIPFromPixel(mVisibleViewArea.bottom));\n    coordinates.putDouble("),n("span",{staticClass:"hljs-string"},[e._v('"screenX"')]),e._v(", PixelUtil.toDIPFromPixel(mVisibleViewArea.left));\n    coordinates.putDouble("),n("span",{staticClass:"hljs-string"},[e._v('"width"')]),e._v(", PixelUtil.toDIPFromPixel(mVisibleViewArea.width()));\n    coordinates.putDouble("),n("span",{staticClass:"hljs-string"},[e._v('"height"')]),e._v(", PixelUtil.toDIPFromPixel(mKeyboardHeight));\n    params.putMap("),n("span",{staticClass:"hljs-string"},[e._v('"endCoordinates"')]),e._v(", coordinates);\n    sendEvent("),n("span",{staticClass:"hljs-string"},[e._v('"keyboardDidShow"')]),e._v(", params);\n} "),n("span",{staticClass:"hljs-keyword"},[e._v("else")]),e._v(" "),n("span",{staticClass:"hljs-keyword"},[e._v("if")]),e._v(" (mKeyboardHeight != "),n("span",{staticClass:"hljs-number"},[e._v("0")]),e._v(" && heightDiff <= mMinKeyboardHeightDetected) {\n    "),n("span",{staticClass:"hljs-comment"},[e._v("// keyboard is now hidden")]),e._v("\n    mKeyboardHeight = "),n("span",{staticClass:"hljs-number"},[e._v("0")]),e._v(";\n    sendEvent("),n("span",{staticClass:"hljs-string"},[e._v('"keyboardDidHide"')]),e._v(", "),n("span",{staticClass:"hljs-keyword"},[e._v("null")]),e._v(");\n}")])]),n("p",[e._v("嗯，安卓下的事件就在这里了。"),n("code",[e._v("keyboardDidShow")]),e._v(" 和 "),n("code",[e._v("keyboardDidHide")]),e._v("。")]),e._v(" "),n("p",[e._v("看来 "),n("a",{attrs:{href:"https://github.com/Andr3wHur5t/react-native-keyboard-spacer/blob/master/KeyboardSpacer.js",target:"_blank"}},[e._v("react-native-keyboard-spacer")]),e._v("  还是很靠谱的。于是从其中抽取了键盘的逻辑，做成了 "),n("a",{attrs:{href:"https://github.com/AngusFu/react-native-keyboard-event",target:"_blank"}},[e._v("react-native-keyboard-event")]),e._v(" 这个组件。可以使用 "),n("code",[e._v("npm")]),e._v(" 来安装。")]),e._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[e._v("\n"),n("span",{staticClass:"hljs-keyword"},[e._v("import")]),e._v(" KeyListener "),n("span",{staticClass:"hljs-keyword"},[e._v("from")]),e._v(" "),n("span",{staticClass:"hljs-string"},[e._v("'react-native-keyboard-event'")]),e._v(";\nKeyListener.show(onkeyboardShow).hide(onkeyboardHide);\n"),n("span",{staticClass:"hljs-comment"},[e._v("// Note")]),e._v("\n"),n("span",{staticClass:"hljs-comment"},[e._v("// event name is up to platform")]),e._v("\nKeyListener.hideEvent;\nKeyListener.showEvent;")])]),n("h2",{attrs:{id:"fetch-"}},[e._v("fetch 方法")]),e._v(" "),n("p",[n("code",[e._v("fetch")]),e._v(" 方法调用最好加上 "),n("code",[e._v("done")]),e._v(" 方法，否则有时候会报错。")]),e._v(" "),n("h2",{attrs:{id:"rn-"}},[e._v("RN 请求数量限制")]),e._v(" "),n("p",[e._v("网络请求数量需要做限制。不能无限请求，否则请求都会被阻塞一直发布出去。")]),e._v(" "),n("p",[e._v("为什么会遇到这种情况呢？因为底层有个死循环，四秒钟查找一次，是否有未上传的记录，若有则会通知前端上传，前端上传结果会反馈给底层。最后出现同一条记录反复通知反复失败的情况。通过分析日志，发现前端接到了通知，但 "),n("code",[e._v("fetch")]),e._v(" 成功、失败的逻辑都没进去。")]),e._v(" "),n("p",[e._v("最后的解决办法，很简单，底层对请求数量做限制。")]),e._v(" "),n("p",[e._v("To be continued...")])])},[],!1,null,null,null);t.default=component.exports}}]);