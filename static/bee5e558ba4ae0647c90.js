(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{180:function(t,e,v){"use strict";v.r(e);var r={computed:{data:function(){return{title:"[译] 手把手教你写一个 Javascript 框架：数据绑定",description:"手把手教你写一个 Javascript 框架：数据绑定",keywords:"翻译,ES6,数据绑定",pathname:"data-bind-dirty-checking",translation:{author:"Bertalan Miklos",social:"https://blog.risingstack.com/author/bertalan/",from:"https://blog.risingstack.com/writing-a-javascript-framework-data-binding-dirty-checking/"},create_time:"2016-11-14",prev:{title:"[译] 手把手教你写一个 Javascript 框架：执行调度",pathname:"execution-timing"},next:{title:"[译] 手把手教你写一个 Javascript 框架：使用 ES6 Proxy 实现数据绑定",pathname:"es6-proxy-data-binding"}}}}},_=v(3),component=Object(_.a)(r,function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("post",{attrs:{data:t.data}},[v("p",[v("strong",[t._v("本文是“编写 JavaScript 框架”系列的第四章。本章我将解释脏检查和基于getter/setter 访问器的数据绑定技术，并指出它们各自的优缺点。")])]),t._v(" "),v("p",[t._v("本系列主要是如何开发一个开源的客户端框架，框架名为 NX。我将在本系列中分享框架编写过程中如何克服遇到的主要困难。对 NX 感兴趣的朋友可以点击 NX 项目"),v("a",{attrs:{href:"http://nx-framework.com/",target:"_blank"}},[t._v("主页")]),t._v("查看。")]),t._v(" "),v("p",[t._v("本系列章节如下：")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"/post/nx-project-structure/"}},[t._v("项目结构（Project structuring）")])]),t._v(" "),v("li",[v("a",{attrs:{href:"/post/execution-timing/"}},[t._v("执行调度（Execution timing）")])]),t._v(" "),v("li",[v("a",{attrs:{href:"/post/sandbox-code-evaluation/"}},[t._v("沙箱求值（Sandboxed code evaluation）")])]),t._v(" "),v("li",[t._v("数据绑定简介(本文)")]),t._v(" "),v("li",[v("a",{attrs:{href:"/post/es6-proxy-data-binding/"}},[t._v("ES6 Proxy 实现数据绑定")])]),t._v(" "),v("li",[t._v("自定义元素")]),t._v(" "),v("li",[t._v("客户端路由")])]),t._v(" "),v("h2",{attrs:{id:"-"}},[t._v("数据绑定简介")]),t._v(" "),v("blockquote",[v("p",[t._v("数据绑定是将数据源与数据提供者、消费者绑定并在它们之间保持同步的一种基本技术。")])]),t._v(" "),v("p",[t._v("上面这个基本定义指出了数据绑定技术的通用构建模块。")]),t._v(" "),v("ul",[v("li",[t._v("定义数据提供者、消费者")]),t._v(" "),v("li",[t._v("定义哪些变化触发数据同步")]),t._v(" "),v("li",[t._v("数据提供者监听变化的方式")]),t._v(" "),v("li",[t._v("发送变化时运行的同步函数 —— 下文会将该函数称作 "),v("code",[t._v("handler()")])])]),t._v(" "),v("p",[t._v("不同数据绑定技术采用不同方式实现以上几步。接下来几个小节介绍其中两种技术，即脏检查、getter/setter 访问器方法。介绍完它们后我将简要讨论它们各自的优缺点。")]),t._v(" "),v("h3",{attrs:{id:"-"}},[t._v("脏检查")]),t._v(" "),v("p",[t._v("脏检查可能是最广为人知的数据绑定方法。它是一种不错的传统选择，因其概念简单，无需复杂的语言特性支持。")]),t._v(" "),v("h3",{attrs:{id:"-"}},[t._v("脏检查语法")]),t._v(" "),v("p",[t._v("定义数据提供者和消费者无需任何特殊语法，仅靠普通 JavaScript 对象即可。")]),t._v(" "),v("pre",[v("code",{staticClass:"hljs lang-javascript"},[v("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" provider = {\n  "),v("span",{staticClass:"hljs-attr"},[t._v("message")]),t._v(": "),v("span",{staticClass:"hljs-string"},[t._v("'Hello World'")]),t._v("\n}\n"),v("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" consumer = "),v("span",{staticClass:"hljs-built_in"},[t._v("document")]),t._v(".createElement("),v("span",{staticClass:"hljs-string"},[t._v("'p'")]),t._v(")")])]),v("p",[t._v("数据同步通常由提供者属性变化触发。那些需要对变化进行观察的属性，必须明确映射到各自的"),v("code",[t._v("handler()")]),t._v("函数。")]),t._v(" "),v("pre",[v("code",{staticClass:"hljs lang-javascript"},[t._v("observe(provider, "),v("span",{staticClass:"hljs-string"},[t._v("'message'")]),t._v(", message => {\n  consumer.innerHTML = message\n})")])]),v("p",[v("code",[t._v("observe()")]),t._v(" 函数仅仅保存了 "),v("code",[t._v("(provider, property) -> handler")]),t._v(" 映射，留作后用。")]),t._v(" "),v("pre",[v("code",{staticClass:"hljs lang-javascript"},[v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),v("span",{staticClass:"hljs-title"},[t._v("observe")]),t._v(" ("),v("span",{staticClass:"hljs-params"},[t._v("provider, prop, handler")]),t._v(") ")]),t._v("{\n  provider._handlers[prop] = handler\n}")])]),v("p",[t._v("这样一来就可以定义数据提供者、消费者，为属性变化注册"),v("code",[t._v("handler()")]),t._v("函数。公有 API 部分已经完成，下面要完成的是内部实现。")]),t._v(" "),v("h3",{attrs:{id:"-"}},[t._v("监听变化")]),t._v(" "),v("p",[t._v("脏检查之所以“脏”是有原因的。它依赖周期性检查，而非直接监听属性变化。这种周期性检查通常称作 digest cycle。在一个 digest cycle 内，遍历由"),v("code",[t._v("observe()")]),t._v("所添加的每一个 "),v("code",[t._v("(provider, property) -> handler")]),t._v(" 入口，并检查属性自上一次遍历以来是否发生了变化。若发生变化，则运行"),v("code",[t._v("handler()")]),t._v("函数。简单实现如下：")]),t._v(" "),v("pre",[v("code",{staticClass:"hljs lang-javascript"},[v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),v("span",{staticClass:"hljs-title"},[t._v("digest")]),t._v(" ("),v("span",{staticClass:"hljs-params"}),t._v(") ")]),t._v("{\n  providers.forEach(digestProvider)\n}\n\n"),v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),v("span",{staticClass:"hljs-title"},[t._v("digestProvider")]),t._v(" ("),v("span",{staticClass:"hljs-params"},[t._v("provider")]),t._v(") ")]),t._v("{\n  "),v("span",{staticClass:"hljs-keyword"},[t._v("for")]),t._v(" ("),v("span",{staticClass:"hljs-keyword"},[t._v("let")]),t._v(" prop "),v("span",{staticClass:"hljs-keyword"},[t._v("in")]),t._v(" provider._handlers) {\n    "),v("span",{staticClass:"hljs-keyword"},[t._v("if")]),t._v(" (provider._prevValues[prop] !== provider[prop]) {\n      provider._prevValues[prop] = provider[prop]\n      handler(provider[prop])\n    }\n  }\n}")])]),v("p",[v("code",[t._v("digest()")]),t._v(" 函数需要不时运行，以保障状态同步。")]),t._v(" "),v("h2",{attrs:{id:"getter-setter-"}},[t._v("getter/setter 访问器方法")]),t._v(" "),v("p",[t._v("getter/setter 访问器方法是当前的主流趋势，其支持广泛程度稍低，因为需要用到 ES5 getter/setter 功能。但这种方法之优雅足以弥补这个问题。")]),t._v(" "),v("h3",{attrs:{id:"-"}},[t._v("访问器语法")]),t._v(" "),v("p",[t._v("定义数据提供者需要一些特殊语法。普通提供者对象需要传给"),v("code",[t._v("observable()")]),t._v("函数，转换为可观察对象。")]),t._v(" "),v("pre",[v("code",{staticClass:"hljs lang-javascript"},[v("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" provider = observable({\n  "),v("span",{staticClass:"hljs-attr"},[t._v("greeting")]),t._v(": "),v("span",{staticClass:"hljs-string"},[t._v("'Hello'")]),t._v(",\n  "),v("span",{staticClass:"hljs-attr"},[t._v("subject")]),t._v(": "),v("span",{staticClass:"hljs-string"},[t._v("'World'")]),t._v("\n})\n"),v("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" consumer = "),v("span",{staticClass:"hljs-built_in"},[t._v("document")]),t._v(".createElement("),v("span",{staticClass:"hljs-string"},[t._v("'p'")]),t._v(")")])]),v("p",[t._v("这完全可以弥补简单的 "),v("code",[t._v("handler()")]),t._v(" 映射语法。在脏检查中，我们必须像下面这样，为每一个观察属性明确进行定义：")]),t._v(" "),v("pre",[v("code",{staticClass:"hljs lang-javascript"},[t._v("observe(provider, "),v("span",{staticClass:"hljs-string"},[t._v("'greeting'")]),t._v(", greeting => {\n  consumer.innerHTML = greeting + "),v("span",{staticClass:"hljs-string"},[t._v("' '")]),t._v(" + provider.subject\n})\n\nobserve(provider, "),v("span",{staticClass:"hljs-string"},[t._v("'subject'")]),t._v(", subject => {\n  consumer.innerHTML = provider.greeting + "),v("span",{staticClass:"hljs-string"},[t._v("' '")]),t._v(" + subject\n})")])]),v("p",[t._v("又笨又长。访问器技术可以在 "),v("code",[t._v("handler()")]),t._v(" 函数中自动检测用到的提供者属性，这样就可以简化以上代码。")]),t._v(" "),v("pre",[v("code",{staticClass:"hljs lang-javascript"},[t._v("observe("),v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-params"},[t._v("()")]),t._v(" =>")]),t._v(" {\n  consumer.innerHTML = provider.greeting + "),v("span",{staticClass:"hljs-string"},[t._v("' '")]),t._v(" + provider.subject\n})")])]),v("p",[v("code",[t._v("observe()")]),t._v(" 的实现与脏检查并不相同。我们仅仅需要执行传入的 "),v("code",[t._v("handler()")]),t._v("，并在其执行期间将其标记为当前活动函数。")]),t._v(" "),v("pre",[v("code",{staticClass:"hljs lang-javascript"},[v("span",{staticClass:"hljs-keyword"},[t._v("let")]),t._v(" activeHandler\n\n"),v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),v("span",{staticClass:"hljs-title"},[t._v("observe")]),t._v("("),v("span",{staticClass:"hljs-params"},[t._v("handler")]),t._v(") ")]),t._v("{\n  activeHandler = handler\n  handler()\n  activeHandler = "),v("span",{staticClass:"hljs-literal"},[t._v("undefined")]),t._v("\n}")])]),v("p",[t._v("我们利用 JavaScript 单线程特点，采用单一的"),v("code",[t._v("activehandler")]),t._v("变量来记录当前运行的"),v("code",[t._v("handler()")]),t._v(" 函数。")]),t._v(" "),v("h3",{attrs:{id:"-"}},[t._v("监听变化")]),t._v(" "),v("p",[t._v("“访问器技术”终于闪亮登场。借助于 getter/setter 访问器在背后的强力支持，数据提供者 provider 的能力大大增强。基本的思想是，拦截 provider 的属性获取、设置操作。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("get：如果存在正在运行的"),v("code",[t._v("activeHandler")]),t._v("，则保存"),v("code",[t._v("(provider, property) -> activeHandler")]),t._v("映射，稍后使用。")])]),t._v(" "),v("li",[v("p",[t._v("set：运行所有 "),v("code",[t._v("(provide, property)")]),t._v(" 对应的 "),v("code",[t._v("handler()")]),t._v("函数。")])])]),t._v(" "),v("p",[v("img",{directives:[{name:"lazy",rawName:"v-lazy",value:"https://s.ssl.qhres2.com/static/363a87a8b3f27981.svg",expression:"`https://s.ssl.qhres2.com/static/363a87a8b3f27981.svg`"}],attrs:{alt:"The accessor data binding technique."}})]),t._v(" "),v("p",[t._v("下面是监听单个属性变化的简单实现：")]),t._v(" "),v("pre",[v("code",{staticClass:"hljs lang-javascript"},[v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),v("span",{staticClass:"hljs-title"},[t._v("observableProp")]),t._v(" ("),v("span",{staticClass:"hljs-params"},[t._v("provider, prop")]),t._v(") ")]),t._v("{\n  "),v("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" value = provider[prop]\n  "),v("span",{staticClass:"hljs-built_in"},[t._v("Object")]),t._v(".defineProperty(provider, prop, {\n    get () {\n      "),v("span",{staticClass:"hljs-keyword"},[t._v("if")]),t._v(" (activeHandler) {\n        provider._handlers[prop] = activeHandler\n      }\n      "),v("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" value\n    },\n    set (newValue) {\n      value = newValue\n      "),v("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" handler = obj._handlers[prop]\n      "),v("span",{staticClass:"hljs-keyword"},[t._v("if")]),t._v(" (handler) {\n        activeHandler = handler\n        handler()\n        activeHandler = "),v("span",{staticClass:"hljs-literal"},[t._v("undefined")]),t._v("\n      }\n    }\n  })\n}")])]),v("p",[t._v("上一节提到的"),v("code",[t._v("observable()")]),t._v("函数会递归遍历 provider 的属性，并使用 "),v("code",[t._v("observableProp()")]),t._v(" 函数将它们统统转换为可观察对象。")]),t._v(" "),v("pre",[v("code",{staticClass:"hljs lang-javascript"},[v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),v("span",{staticClass:"hljs-title"},[t._v("observable")]),t._v(" ("),v("span",{staticClass:"hljs-params"},[t._v("provider")]),t._v(") ")]),t._v("{\n  "),v("span",{staticClass:"hljs-keyword"},[t._v("for")]),t._v(" ("),v("span",{staticClass:"hljs-keyword"},[t._v("let")]),t._v(" prop "),v("span",{staticClass:"hljs-keyword"},[t._v("in")]),t._v(" provider) {\n    observableProp(provider, prop)\n    "),v("span",{staticClass:"hljs-keyword"},[t._v("if")]),t._v(" ("),v("span",{staticClass:"hljs-keyword"},[t._v("typeof")]),t._v(" provider[prop] === "),v("span",{staticClass:"hljs-string"},[t._v("'object'")]),t._v(") {\n      observable(provider[prop])\n    }\n  }\n}")])]),v("p",[t._v("这只是一个简单实现，但用来对比两种技术已足够。")]),t._v(" "),v("h2",{attrs:{id:"-"}},[t._v("两种技术对比")]),t._v(" "),v("p",[t._v("本节将简要指出脏检查和访问器两种技术各自的优缺点。")]),t._v(" "),v("h3",{attrs:{id:"-"}},[t._v("语法形式")]),t._v(" "),v("p",[t._v("脏检查无需定义提供者、消费者，但将 "),v("code",[t._v("(provider, property)")]),t._v(" 和 "),v("code",[t._v("handler()")]),t._v(" 进行映射的方式笨拙又不灵活。")]),t._v(" "),v("p",[t._v("访问器技术需要使用 "),v("code",[t._v("observable()")]),t._v(" 函数对提供者进行封装，不过自动进行 "),v("code",[t._v("handler()")]),t._v(" 映射弥补了不足。对于使用数据绑定的大型项目来说，访问器技术是必备特性。")]),t._v(" "),v("h3",{attrs:{id:"-"}},[t._v("性能")]),t._v(" "),v("p",[t._v("脏检查早就因其性能表现臭名昭著。每次 digest cycle 中，需要对每个 "),v("code",[t._v("(provider, property) -> handler")]),t._v(" 入口进行数次检查。此外，即便应用处于闲置状态也必须保持运转，因为它并不值得属性何时发生变化。")]),t._v(" "),v("p",[t._v("访问器方法更快一些，但在一些大型可观察对象面前，性能也可能发生退化。使用访问器替换提供者的所有属性，通常是过重了。一种解决办法是在必要时动态建立 getter/setter，而不是一次性提前完成。此外，还有一种简单方法是使用一个 "),v("code",[t._v("noObserve()")]),t._v(" 函数包装不需要的属性，告诉 "),v("code",[t._v("observable()")]),t._v(" 不要理会这些。但这会引入额外的语法。")]),t._v(" "),v("h3",{attrs:{id:"-"}},[t._v("灵活性")]),t._v(" "),v("p",[t._v("脏检查天生就能和扩展属性（动态添加的）以及访问器属性一起工作。")]),t._v(" "),v("p",[t._v("访问器技术在这方面有个弱点。初始化 getter/setter 时，扩展属性并不包含在内。比如对数组来说，这就会导致问题，但也能通过手动调用 "),v("code",[t._v("observableProp()")]),t._v(" 来解决。访问器属性也无法支持，因为访问器属性无法再包装一次。一种常见的解决办法是使用 "),v("code",[t._v("computed()")]),t._v(" 函数替代 getter。不过这会引入更多自定义语法。")]),t._v(" "),v("h3",{attrs:{id:"-"}},[t._v("时间控制")]),t._v(" "),v("p",[t._v("脏检查给我们的自由并不多，因为我们无从得知属性实际发生变化的时机。"),v("code",[t._v("handler()")]),t._v(" 函数只能通过不时运行 "),v("code",[t._v("digest()")]),t._v(" 循环而异步执行。")]),t._v(" "),v("p",[t._v("使用访问器技术，getter/setter 是同步触发的，因此就有了选择上的自由。我们可以决定是否立即执行 "),v("code",[t._v("handler()")]),t._v("，或者分批异步执行。前者保证了可预见性，后者则可以通过去重提升性能。")]),t._v(" "),v("h2",{attrs:{id:"-"}},[t._v("关于下一章")]),t._v(" "),v("p",[t._v("下一章我将介绍 "),v("a",{attrs:{href:"https://github.com/RisingStack/nx-observe",target:"_blank"}},[t._v("nx-observe")]),t._v(" 数据绑定工具，阐述如何用 ES6 Proxy 替代  ES5 getters/setters，以弥补访问器技术的多数不足之处。")]),t._v(" "),v("h2",{attrs:{id:"-"}},[t._v("写在最后")]),t._v(" "),v("p",[t._v("如果对 NX 框架感兴趣，请访问 "),v("a",{attrs:{href:"http://nx-framework.com/",target:"_blank"}},[t._v("主页")]),t._v("。胆大的读者还可以在Github 上查看 "),v("a",{attrs:{href:"https://github.com/RisingStack/nx-framework",target:"_blank"}},[t._v("NX 源码")]),t._v(" 和 "),v("a",{attrs:{href:"https://github.com/RisingStack/nx-observe",target:"_blank"}},[t._v("nx-observe 源码")]),t._v("。")]),t._v(" "),v("p",[t._v("希望你喜欢这篇文章。下一章我们将讨论 "),v("a",{attrs:{href:"https://blog.risingstack.com/writing-a-javascript-framework-sandboxed-code-evaluation/",target:"_blank"}},[t._v("沙箱求值（Sandboxed code evaluation）")]),t._v("。")])])},[],!1,null,null,null);e.default=component.exports}}]);