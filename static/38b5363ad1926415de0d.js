(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{206:function(t,e,v){"use strict";v.r(e);var _={computed:{data:function(){return{title:"关于JavaScript 函数传参",description:"关于JavaScript 函数传参",keywords:"原创,JavaScript,Node.js",pathname:"javascript-argument",translation:null,create_time:"2016-06-26",prev:{title:"[译] 小两百行 JavaScript 打造 lambda 演算解释器",pathname:"writing-a-lambda-calculus-interpreter-in-javascript"},next:{title:"[译] 客户端存储",pathname:"client-side-storage"}}}}},r=v(3),component=Object(r.a)(_,function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("post",{attrs:{data:t.data}},[v("p",[t._v("周五晚上下班回家的路上，突然想到了 CommonJS 规范、Node.js 模块化等等各种东西，然后就想到了熟悉的 "),v("code",[t._v("module.exports")]),t._v("。")]),t._v(" "),v("p",[t._v("大约很久之前看 "),v("a",{attrs:{href:"http://seajs.org/",target:"_blank"}},[v("code",[t._v("seajs")])]),t._v(" 的"),v("a",{attrs:{href:"https://github.com/seajs/seajs/issues/242",target:"_blank"}},[t._v("文档")]),t._v("，文档强调，"),v("code",[t._v("exports = {/**/}")]),t._v(" 这种写法是错误的！当时还是小白中的小白，只能一脸懵逼，为嘛不能啊？完全无法理解。")]),t._v(" "),v("p",[t._v("请看截图：")]),t._v(" "),v("p",[v("img",{directives:[{name:"lazy",rawName:"v-lazy",value:"https://segmentfault.com/img/bVyuNX",expression:"`https://segmentfault.com/img/bVyuNX`"}],attrs:{alt:"clipboard.png"}})]),t._v(" "),v("p",[t._v("有没有看到最后的提示？可惜那时候的小白文蔺完全不知道这是什么鬼——更可能的是那会儿就没关注到这一块儿，毕竟新人，心浮气躁，就想五分钟学会 seajs 模块化开发。")]),t._v(" "),v("p",[t._v("后来摸爬滚打，js 知识相对扎实之后（鸣谢厚厚的红宝书《 JavaScript 高级程序设计》，前后读了三遍），我还是好歹懂了，但未能举一反三。")]),t._v(" "),v("p",[t._v("昨天晚上，再次冒出这个问题，还是了然的。")]),t._v(" "),v("blockquote",[v("p",[t._v("子曰： 学而不思则罔，思而不学则殆。")])]),t._v(" "),v("p",[t._v("很显然，"),v("code",[t._v("exports")]),t._v(" 在 "),v("code",[t._v("define(function(require, exports) {})")]),t._v("中就是个局部变量，它对应的值是个对象，是 "),v("code",[t._v("module.exports")]),t._v(" 的一个引用。")]),t._v(" "),v("p",[t._v("然后呢，一句"),v("code",[t._v("exports = {/**/}")]),t._v("就把这个局部变量指向另外一个值了。这是局部变量啊喂。卒。")]),t._v(" "),v("p",[t._v("很多新人看了一些博客或者书之后，脑子里也打结了，"),v("code",[t._v("求值策略")]),t._v("，"),v("code",[t._v("按值传递")]),t._v("，"),v("code",[t._v("按引用传递")]),t._v("，这些似是而非的概念最后都把人给整糊涂了。")]),t._v(" "),v("p",[t._v("刚刚刷SF，读到一篇文章，"),v("a",{attrs:{href:"https://segmentfault.com/a/1190000005794070",target:"_blank"}},[t._v("《JS中的值是按值传递，还是按引用传递呢？》")]),t._v("，和我思考的有点类似。")]),t._v(" "),v("p",[t._v("然后搜索了下 “求值策略”，找到"),v("strong",[t._v("汤姆大叔")]),t._v("的"),v("a",{attrs:{href:"http://www.cnblogs.com/TomXu/archive/2012/02/08/2341439.html",target:"_blank"}},[t._v("一篇文章")]),t._v("，上文与大叔的这篇文章还挺类似的，但大叔的可能显得更深入一点。")]),t._v(" "),v("p",[t._v("下面是引用：")]),t._v(" "),v("blockquote",[v("p",[t._v("准确的说，JS中的基本类型按值传递，对象类型按共享传递的(call by sharing，也叫按对象传递、按对象共享传递)。最早由Barbara Liskov. 在1974年的GLU语言中提出。该求值策略被用于Python、Java、Ruby、JS等多种语言。")]),t._v(" "),v("p",[t._v("该策略的重点是：调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值。")])]),t._v(" "),v("p",[t._v("从科学的角度来说，对于概念什么的，可能还是挺有必要的。从实用角度来说，只要能正确理解，可能用自己的一套语言来描述也是可以的。")])])},[],!1,null,null,null);e.default=component.exports}}]);