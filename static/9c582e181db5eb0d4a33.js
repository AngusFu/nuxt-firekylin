(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{187:function(t,v,e){"use strict";e.r(v);var _={computed:{data:function(){return{title:"[译] 事件代理：模式 or 反模式？",description:"事件代理：模式 or 反模式？",keywords:"翻译,设计模式",pathname:"event-delegation-pattern-or-anti-pattern",translation:{author:"@Neil Roberts",social:"https://www.sitepen.com/blog/author/nroberts/",from:"https://www.sitepen.com/blog/2017/07/11/event-delegation-pattern-or-anti-pattern/"},create_time:"2017-07-19",prev:{title:"[译] font-display 的使用",pathname:"font-display"},next:{title:"函数响应式编程 —— RxJS 简介",pathname:"functional-programming"}}}}},r=e(3),component=Object(r.a)(_,function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("post",{attrs:{data:t.data}},[e("p",[e("img",{directives:[{name:"lazy",rawName:"v-lazy",value:"https://p5.ssl.qhimg.com/t016f64f144c3f7563b.jpg",expression:"`https://p5.ssl.qhimg.com/t016f64f144c3f7563b.jpg`"}],attrs:{alt:""}})]),t._v(" "),e("p",[t._v("JavaScript 工具包（toolkit）和框架所做的大量工作，都集中于尝试修复、规范或优化浏览器的功能实现。此类工作需要做出许多假设，这些假设包括：问题是什么，开发人员将如何使用我们的工具，以及我们对未来的期望。")]),t._v(" "),e("p",[t._v("但这些假设经常是错误的。更有甚者，在很长一段时间内，这些选择可能貌似正确，直至某天我们被问题反咬一口。在这个无知的幸福时期当中，我们的工具包可能变得相当受欢迎，并成为大型复杂代码库的重要组成部分。")]),t._v(" "),e("h2",{attrs:{id:"-"}},[t._v("事件冒泡与事件代理")]),t._v(" "),e("p",[t._v("事件冒泡允许源自子节点的事件向父级节点“冒泡”（bubble）。这种行为导致 JavaScript 开发者使用松散的设计模式来识别我们所关心的接收事件的节点 —— 通常使用 CSS 选择器 —— 同时将事件监听器添加到该节点的父级节点上。")]),t._v(" "),e("p",[t._v("一旦这种模式进入工具包之中，设计 API 时须做出一些假设。在开始阶段，这些假设主要围绕性能与效率展开。")]),t._v(" "),e("p",[t._v("事件代理（Event Delegation）是处理事件的实际方法之一。然而，这种方法论适用于所有项目吗？实际上，更好的问题可能是，每个工具包的所基于的假设是否与你的项目需求相符。要想知道某个 API 是否适合当下项目，就要了解这些工具是建立在哪些假设之上的，并且理解每个工具包如何解释它们。")]),t._v(" "),e("h2",{attrs:{id:"-"}},[t._v("假设")]),t._v(" "),e("p",[t._v("一起来看看，在思考如何有效管理 DOM 事件时可能会产生的一些假设。")]),t._v(" "),e("h3",{attrs:{id:"-"}},[t._v("本机事件注册机制太慢")]),t._v(" "),e("p",[t._v("在你能够提出 API 存在的继发原因之前，不要创建新的 API。随着浏览器厂商们对运行时的投入增加，你的功能实现总有一天会比原生实现慢。我所在的 SitePen 有一个项目依赖于数组拼接（splice）速度。我们发现，在某些情况下，手动操作索引和数组长度能够带来显著的性能提升。但我们无法定位到特定浏览器、浏览器版本或平台，因为无法进行运行时功能测试以确定我们的实现是否比原生 API 快。")]),t._v(" "),e("h3",{attrs:{id:"-api-"}},[t._v("新的原生 API 不会出现")]),t._v(" "),e("p",[t._v("保持谨慎，确保已收集到足够的信息，可以降级使用原生实现 —— 无论是已存在的，还是理想情况下可能存在的。这项工作的另一个名字叫“预防过时”（future proofing）。在某些情况下，你可能会使用必需参数超出绝对需要的 API，但如果它l能够保证轻松地过渡到更优秀的原生 API，那么完全可以如此。一个很好的例子是最终获得原生支持的 "),e("code",[t._v("querySelectorAll")]),t._v(" API，之前许多开发人员假设这种事永远不会发生。")]),t._v(" "),e("h3",{attrs:{id:"-"}},[t._v("不常见用例没有性能损失")]),t._v(" "),e("p",[t._v("事件代理可能会以数种方式呈现。例如两种特殊情况：大量节点上的少量事件，以及少数节点上的大量事件。如果针对其中之一进行优化，则可能会为另一个带来明显的瓶颈。虽然使用事件代理可能只需要向单个节点添加一个事件侦听器，但识别触发回调的节点的复杂方法对性能的影响可能不成比例。快速触发大量事件（例如鼠标移动或滚动事件）正是使用事件代理的场景。")]),t._v(" "),e("h3",{attrs:{id:"-"}},[t._v("条件与背景")]),t._v(" "),e("p",[t._v("在考虑事件代理时，很容易认为我们只需要关心用户交互。这可能导致我们假设节点始终是文档的一部分，然后开始思考，为何不在 document 对象上添加单个事件处理程序呢？"),e("strong",[t._v("DOM 事件并非总是用户交互的结果 —— 我们也有人为事件、自定义事件以及加载事件等。")]),t._v("如果想要监听的节点不在文档中，而监听器却绑定在 document 对象上，我们永远得不到通知。如果在 API 中无法区别监听器是添加到 document 上，抑或是添加到我们所传递的参数上，则能够理解为什么会出现这种情况。")]),t._v(" "),e("h3",{attrs:{id:"-"}},[t._v("抽象")]),t._v(" "),e("p",[t._v("如果一个工具包提供一个仅用于支持代理的事件处理 API —— 需要父级节点和标识子节点的选择器 —— 则无法将事件监听器直接添加到某个节点。即使是使用 CSS 选择器，也引入了更高级的功能，可以轻松地使用另一种选择器语法或简单函数。")]),t._v(" "),e("h3",{attrs:{id:"-"}},[t._v("不会发生副作用")]),t._v(" "),e("p",[t._v("如上所述，DOM 事件冒泡是事件代理模式存在的前提。但是了解完整规范所涉及的内容之后，你会发现，事件冒泡是可以取消的。你的实现可能会将 stopPropagation 方法为空函数的自定义事件传递给回调函数；或者，你可能只会记录问题，并限制事件代理 API 的使用。这两种方法都有问题，但是如果你打算像为 document 对象事件处理程序那样工作，添加大量可取消的事件层可能放大副作用。")]),t._v(" "),e("h3",{attrs:{id:"-"}},[t._v("不受时间影响")]),t._v(" "),e("p",[t._v("一旦代码编写完成，很可能就会弃而不顾。但浏览器正在以我们无法想象、预测的方式向前发展，我们在编写代码时所做的假设可能会被证明是错误的，尽管我们尽了最大的努力。")]),t._v(" "),e("h2",{attrs:{id:"-"}},[t._v("总结")]),t._v(" "),e("p",[t._v("为什么要在项目中使用事件代理？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("原生实现太慢了吗？对现代浏览器来说不太可能。")])]),t._v(" "),e("li",[e("p",[t._v("是否有更好的 API 来执行事件代理？目前还没有 —— 如果你需要事件代理，这是一个很好的模式。")])]),t._v(" "),e("li",[e("p",[t._v("该工具包的性能优化是否符合项目需求？如果它专注于特殊情况，可能不会。")])]),t._v(" "),e("li",[e("p",[t._v("工具包的实现中有没有什么不适用于你的项目的内容？阅读文档，这些通常都会标出。")])]),t._v(" "),e("li",[e("p",[t._v("是否有副作用？遇到错误前你可能不会发现这一点，所以要特别注意。")])])]),t._v(" "),e("p",[t._v("人们在不了解创作假设的情况下，所有设计模式都有成为反模式的风险，所以对项目中使用的任何新工具都应当回答同样的问题。如果你所做的似乎是在抄近路，要特别小心。谨慎、多加思考，才能使项目发光。")])])},[],!1,null,null,null);v.default=component.exports}}]);