(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{195:function(t,e,n){"use strict";n.r(e);var _={computed:{data:function(){return{title:"[译] 内容加速黑科技趣谈",description:"内容加速黑科技趣谈",keywords:"翻译,JavaScript,性能",pathname:"fun-hacks-faster-content",translation:{author:"@Jake Archibald",social:"https://jakearchibald.com/",from:"https://jakearchibald.com/2016/fun-hacks-faster-content/"},create_time:"2017-04-28",prev:{title:"Facebook 开源代码优化工具 Prepack",pathname:"prepack"},next:{title:"[译] Emoji.prototype.length  —— Unicode 字符那些事儿",pathname:"unicode-javascript-and-the-emoji-family"}}}}},v=n(3),component=Object(v.a)(_,function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("post",{attrs:{data:t.data}},[n("p",[t._v("数周前，在伦敦 Heathrow 机场等飞机的空闲中，我顺便处理了一些工作上的事情。不经意间发现 Github 在性能方面的一些问题，颇为诧异。通过新 tab 打开的页面，其加载速度竟然比直接点击链接打开的页面要快。不信请看视频（译者注：可能需要科学上网）："),n("a",{attrs:{href:"https://www.youtube.com/watch?v=4zG0AZRZD6Q",target:"_blank"}},[t._v("GitHub link click vs new tab")]),t._v("。")]),t._v(" "),n("p",[t._v("点击链接的同时复制链接并在新的 tab 页中打开。可以看到，尽管先点击的是链接，但渲染更快的却是新 tab 中打开的页面。")]),t._v(" "),n("h2",{attrs:{id:"-show-them-what-you-got-"}},[t._v("有一说一（Show them what you got）")]),t._v(" "),n("p",[t._v("页面加载的时候，浏览器会接收网络数据流，并将其输出（pipe）给 HTML 解析器，HTML 解析器再将数据输出到文档。这意味着，页面是边加载边渲染的。对于一个 100k 的页面来说，浏览器很可能在接收到 20k 数据的时候就开始渲染出一些可用内容了。")]),t._v(" "),n("p",[t._v("这个伟大又古老的特性，常常被开发者们有意无意地忽略了。多数提高加载性能的建议都归结于一点，即“展示你所拿到的东西” —— 别怕，千万不要傻傻等待一切加载完成之后再去展示内容。")]),t._v(" "),n("p",[t._v("GitHub 当然是关注性能的，所以他们使用服务端渲染。但在同一个 tab 下浏览页面时，他们用 JavaScript 重新实现了导航（navigation）功能，类似下面这样：")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-comment"},[t._v("// …一堆重新实现浏览器导航功能代码…")]),t._v("\n"),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" response = "),n("span",{staticClass:"hljs-keyword"},[t._v("await")]),t._v(" fetch("),n("span",{staticClass:"hljs-string"},[t._v("'page-data.inc'")]),t._v(");\n"),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" html = "),n("span",{staticClass:"hljs-keyword"},[t._v("await")]),t._v(" response.text();\n"),n("span",{staticClass:"hljs-built_in"},[t._v("document")]),t._v(".querySelector("),n("span",{staticClass:"hljs-string"},[t._v("'.content'")]),t._v(").innerHTML = html;\n"),n("span",{staticClass:"hljs-comment"},[t._v("// …加载更多重新实现导航功能的代码…")])])]),n("p",[t._v("这违反了规则，因为在 "),n("code",[t._v("page-data.inc")]),t._v(" 下载完成之前什么事情都没干。而服务端渲染版完全不会这样囤积内容，其内容是流式的，这样就要快得多了。就 Github 的客户端渲染来说，很多 JavaScript 代码完全减慢了渲染过程。")]),t._v(" "),n("p",[t._v("这里我仅仅只是拿 Github 举例子 —— 这种反模式在单页应用中比比皆是。")]),t._v(" "),n("p",[t._v("在页面之内切换内容可能确实有些好处，特别是存在大量脚本的情况下，无需重新执行全部脚本即可更新内容。但我们能否在不放弃流的情况下完成这样的工作呢？我曾经常说 JavaScript 没有办法对流进行解析，但其实还是有的……")]),t._v(" "),n("h2",{attrs:{id:"iframe-document-write-"}},[t._v("iframe 和 document.write 大法")]),t._v(" "),n("p",[n("code",[t._v("iframe")]),t._v(" 早已跻身圈内最臭黑科技之列。但下面这个办法就使用了 "),n("code",[t._v("iframe")]),t._v(" 和 "),n("code",[t._v("document.write()")]),t._v("，这样我们就能将内容以流的形式添加到页面中了。示例如下：")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-comment"},[t._v("// 创建 iframe:")]),t._v("\n"),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" iframe = "),n("span",{staticClass:"hljs-built_in"},[t._v("document")]),t._v(".createElement("),n("span",{staticClass:"hljs-string"},[t._v("'iframe'")]),t._v(");\n\n"),n("span",{staticClass:"hljs-comment"},[t._v("// 添加到 document 中 (记得隐藏起来):")]),t._v("\niframe.style.display = "),n("span",{staticClass:"hljs-string"},[t._v("'none'")]),t._v(";\n"),n("span",{staticClass:"hljs-built_in"},[t._v("document")]),t._v(".body.appendChild(iframe);\n\n"),n("span",{staticClass:"hljs-comment"},[t._v("// 等待 iframe 加载:")]),t._v("\niframe.onload = "),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-params"},[t._v("()")]),t._v(" =>")]),t._v(" {\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// 忽略其他 onload 操作:")]),t._v("\n  iframe.onload = "),n("span",{staticClass:"hljs-literal"},[t._v("null")]),t._v(";\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// 添加一个虚拟标签:")]),t._v("\n  iframe.contentDocument.write("),n("span",{staticClass:"hljs-string"},[t._v("'<streaming-element>'")]),t._v(");\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// 引用该元素:")]),t._v("\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" streamingElement = iframe.contentDocument.querySelector("),n("span",{staticClass:"hljs-string"},[t._v("'streaming-element'")]),t._v(");\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// 将该元素从 iframe 中取出，并添加到文档中:")]),t._v("\n  "),n("span",{staticClass:"hljs-built_in"},[t._v("document")]),t._v(".body.appendChild(streamingElement);\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// 写入一些内容 —— 这里应该是异步的:")]),t._v("\n  iframe.contentDocument.write("),n("span",{staticClass:"hljs-string"},[t._v("'<p>Hello!</p>'")]),t._v(");\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// 继续写入内容，直到完成:")]),t._v("\n  iframe.contentDocument.write("),n("span",{staticClass:"hljs-string"},[t._v("'</streaming-element>'")]),t._v(");\n  iframe.contentDocument.close();\n};\n\n"),n("span",{staticClass:"hljs-comment"},[t._v("//  iframe 初始化")]),t._v("\niframe.src = "),n("span",{staticClass:"hljs-string"},[t._v("''")]),t._v(";")])]),n("p",[t._v("虽然 "),n("code",[t._v("Hello!")]),t._v(" 是写到 iframe 中的，但它却出现在了父级的 document 中！这是因为"),n("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/syntax.html#parsing",target:"_blank"}},[t._v("解析器")]),t._v("维护了一个"),n("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/syntax.html#stack-of-open-elements",target:"_blank"}},[t._v("敞开元素栈（stack of open elements）")]),t._v("，新创建的元素会被压入栈中。就算我们把 "),n("code",[t._v("<streaming-element/>")]),t._v(" 元素移出到 iframe 外面也不影响，就是这么任性。")]),t._v(" "),n("p",[t._v("此外，这种技术处理起 HTML 来，要比 "),n("code",[t._v("innerHTML")]),t._v(" 更接近标准的页面加载解析器。尤其是脚本依然会被下载，并在父级文档的上下文中执行 —— 只是在 Firefox 中完全不会执行，"),n("del",[t._v("但我认为这是个 bug")]),n("strong",[t._v("更新：")]),t._v(" 其实"),n("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/syntax.html#scripts-that-modify-the-page-as-it-is-being-parsed",target:"_blank"}},[t._v("脚本根本不应该执行")]),t._v("（感谢 "),n("a",{attrs:{href:"https://twitter.com/zcorpan/status/806150847184928768",target:"_blank"}},[t._v("Simon Pieters 指出这一点")]),t._v("），但 Edge、Safari、Chrome 都这么干。")]),t._v(" "),n("p",[t._v("接下来我们只需要从服务端获取 HTML 数据流，每当一个部分的数据到达的时候，就调用 "),n("code",[t._v("iframe.contentDocument.write()")]),t._v("。流式传输和 "),n("code",[t._v("fetch()")]),t._v(" 搭配起来会更好，但为了支持 Safari，我们还是"),n("a",{attrs:{href:"https://github.com/jakearchibald/streaming-html/blob/master/streaming-iframe.js",target:"_blank"}},[t._v("使用 XHR 来 hack")]),t._v(" 一下吧。")]),t._v(" "),n("p",[t._v("我已经写好了一个 demo，可以拿来"),n("a",{attrs:{href:"https://jakearchibald.github.io/streaming-html/",target:"_blank"}},[t._v("和 Github 进行对比")]),t._v("。下面是在 3G 网络下的测试结果：")]),t._v(" "),n("p",[n("img",{directives:[{name:"lazy",rawName:"v-lazy",value:"https://ww3.sinaimg.cn/large/006tNbRwly1ff1n52arbtj31kw0e8q46.jpg",expression:"`https://ww3.sinaimg.cn/large/006tNbRwly1ff1n52arbtj31kw0e8q46.jpg`"}],attrs:{alt:""}})]),t._v(" "),n("p",[n("a",{attrs:{href:"https://www.webpagetest.org/video/compare.php?tests=161206_N2_FJG-r,161206_JP_FPV-r:5-c:0",target:"_blank"}},[t._v("点击这里查看原始测试数据")]),t._v("。")]),t._v(" "),n("p",[t._v("使用 iframe 进行流式渲染，页面加载速度提高了 "),n("strong",[t._v("1.5 s")]),t._v("。头像也提前半秒钟加载完成 —— 流式渲染意味着浏览器可以更早发现它们，并与内容一起并行下载。")]),t._v(" "),n("p",[t._v("上面的方法对 Github 来说还是有效的，因为它的服务器返回的是 HTML。如果你使用的是框架，由框架自己管理 DOM 的展示，那可能就麻烦一些了。这种情况下可以看看下面这个次优选项：")]),t._v(" "),n("h2",{attrs:{id:"-json-newline-delimited-json-"}},[t._v("换行符分隔的 JSON（Newline-delimited JSON）")]),t._v(" "),n("p",[t._v("许多网站使用 JSON 驱动动态内容。何其不幸，JSON 并不是一种对流友好的格式。尽管也有"),n("a",{attrs:{href:"https://github.com/creationix/jsonparse",target:"_blank"}},[t._v("流式 JSON 解析器")]),t._v("，可用起来却并不那么简单。")]),t._v(" "),n("p",[t._v("所以与其传输下面这样一大块 JSON 数据：")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[t._v("{\n  "),n("span",{staticClass:"hljs-string"},[t._v('"Comments"')]),t._v(": [\n    {"),n("span",{staticClass:"hljs-string"},[t._v('"author"')]),t._v(": "),n("span",{staticClass:"hljs-string"},[t._v('"Alex"')]),t._v(", "),n("span",{staticClass:"hljs-string"},[t._v('"body"')]),t._v(": "),n("span",{staticClass:"hljs-string"},[t._v('"…"')]),t._v("},\n    {"),n("span",{staticClass:"hljs-string"},[t._v('"author"')]),t._v(": "),n("span",{staticClass:"hljs-string"},[t._v('"Jake"')]),t._v(", "),n("span",{staticClass:"hljs-string"},[t._v('"body"')]),t._v(": "),n("span",{staticClass:"hljs-string"},[t._v('"…"')]),t._v("}\n  ]\n}")])]),n("p",[t._v("还不如像下面这样一行输出一个 JSON 对象：")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[t._v("{"),n("span",{staticClass:"hljs-string"},[t._v('"author"')]),t._v(": "),n("span",{staticClass:"hljs-string"},[t._v('"Alex"')]),t._v(", "),n("span",{staticClass:"hljs-string"},[t._v('"body"')]),t._v(": "),n("span",{staticClass:"hljs-string"},[t._v('"…"')]),t._v("}\n{"),n("span",{staticClass:"hljs-string"},[t._v('"author"')]),t._v(": "),n("span",{staticClass:"hljs-string"},[t._v('"Jake"')]),t._v(", "),n("span",{staticClass:"hljs-string"},[t._v('"body"')]),t._v(": "),n("span",{staticClass:"hljs-string"},[t._v('"…"')]),t._v("}")])]),n("p",[t._v("这种被称为 “换行符分隔的 JSON” 是有标准的："),n("a",{attrs:{href:"http://specs.okfnlabs.org/ndjson/",target:"_blank"}},[t._v("ndjson")]),t._v("。给上面的内容写一个解析器就要简单多了。到了 2017 年，我们也许可以使用一系列组合变换流（composable transform streams）来描述（译者注：本文写作于 2016 年 12 月）：")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-comment"},[t._v("// 在 2017 年的某个时候可能会是这样：")]),t._v("\n"),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" response = "),n("span",{staticClass:"hljs-keyword"},[t._v("await")]),t._v(" fetch("),n("span",{staticClass:"hljs-string"},[t._v("'comments.ndjson'")]),t._v(");\n"),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" comments = response.body\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// 从字节到文本:")]),t._v("\n  .pipeThrough("),n("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" TextDecoder())\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// 一直缓冲，直到遇到换行符:")]),t._v("\n  .pipeThrough(splitStream("),n("span",{staticClass:"hljs-string"},[t._v("'\\n'")]),t._v("))\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// 将内容块解析为JSON:")]),t._v("\n  .pipeThrough(parseJSON());\n\n"),n("span",{staticClass:"hljs-keyword"},[t._v("for")]),t._v(" "),n("span",{staticClass:"hljs-keyword"},[t._v("await")]),t._v(" ("),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" comment "),n("span",{staticClass:"hljs-keyword"},[t._v("of")]),t._v(" comments) {\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// 处理每条评论，并将其添加到页面:")]),t._v("\n  "),n("span",{staticClass:"hljs-comment"},[t._v("// (不管你使用的是什么模板或虚拟 DOM)")]),t._v("\n  addCommentToPage(comment);\n}")])]),n("p",[t._v("在上面的代码中，"),n("code",[t._v("splitStream")]),t._v(" 和 "),n("code",[t._v("parseJSON")]),t._v(" 是"),n("a",{attrs:{href:"https://gist.github.com/jakearchibald/c2052ef298459355963b8cfb79c71d1c",target:"_blank"}},[t._v("可复用变换流（reusable transform streams）")]),t._v("。与此同时，为了实现最大程度的兼容，我们可以"),n("a",{attrs:{href:"https://github.com/jakearchibald/streaming-html/blob/master/xhr-ndjson.js",target:"_blank"}},[t._v("使用 XHR 进行 hack")]),t._v("。")]),t._v(" "),n("p",[t._v("我再次新建了一个"),n("a",{attrs:{href:"https://jakearchibald.github.io/streaming-html/",target:"_blank"}},[t._v("对比的 demo")]),t._v("，下面是 3G 网络下的结果：")]),t._v(" "),n("p",[n("img",{directives:[{name:"lazy",rawName:"v-lazy",value:"https://ww3.sinaimg.cn/large/006tNbRwly1ff1noprcsfj31kw0iqjt2.jpg",expression:"`https://ww3.sinaimg.cn/large/006tNbRwly1ff1noprcsfj31kw0iqjt2.jpg`"}],attrs:{alt:""}})]),t._v(" "),n("p",[n("a",{attrs:{href:"https://www.webpagetest.org/video/compare.php?tests=161206_X9_FNG-r,161206_V7_FPJ-r:1-c:0",target:"_blank"}},[t._v("点击这里查看原始测试数据")]),t._v("。")]),t._v(" "),n("p",[t._v("与常规 JSON 相比，ND-JSON "),n("strong",[t._v("提前 1.5s")]),t._v(" 将内容渲染到页面上，尽管速度不如 iframe 方法那么快。在创建元素之前，必须等待完整的 JSON 对象出现。如果你的 JSON 文件体量巨大，可能会陷入对流的企盼之中。")]),t._v(" "),n("h2",{attrs:{id:"-"}},[t._v("单页应用？别着急")]),t._v(" "),n("p",[t._v("如前所述，Github 使用了大量的代码，然而却带来这样的性能问题。在客户端重新实现导航功能是困难的，如果你需要改变页面中的大块内容，这么做有可能并不值得。")]),t._v(" "),n("p",[t._v("可以拿我们的尝试与"),n("a",{attrs:{href:"https://jakearchibald.github.io/streaming-html/",target:"_blank"}},[t._v("简单浏览器导航")]),t._v("进行对比：")]),t._v(" "),n("p",[n("img",{directives:[{name:"lazy",rawName:"v-lazy",value:"https://ww2.sinaimg.cn/large/006tNbRwly1ff1nxa5c4pj31kw0f1t9w.jpg",expression:"`https://ww2.sinaimg.cn/large/006tNbRwly1ff1nxa5c4pj31kw0f1t9w.jpg`"}],attrs:{alt:""}})]),t._v(" "),n("p",[n("a",{attrs:{href:"https://www.webpagetest.org/video/compare.php?tests=161206_JP_FPV-r,161206_V7_FPJ-r,161206_8Y_FN3-r:8-c:0",target:"_blank"}},[t._v("点击这里查看原始测试数据")]),t._v("。")]),t._v(" "),n("p",[t._v("打开一个简单的没有使用 JavaScript 浏览器导航的服务端渲染页面的速度差不多是一样的。但除去评论列表，测试页面实在太过简单。如果在不同页面之间存在有大量重复的复杂内容（主要是指可怕的广告脚本），结果可能因实际情况而有差异，但一定要记得进行测试！很可能你编写了一大堆代码，然而只能带来少的可怜的提升，甚至还可能减慢速度。")]),t._v(" "),n("p",[t._v("鸣谢 "),n("a",{attrs:{href:"https://twitter.com/ElliottZ?s=09",target:"_blank"}},[t._v("Elliott Sprehn")]),t._v(" 关于 HTML 解析器工作原理的赐教！")])])},[],!1,null,null,null);e.default=component.exports}}]);