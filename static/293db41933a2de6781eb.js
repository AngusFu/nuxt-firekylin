(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{167:function(n,t,l){"use strict";l.r(t);var v={computed:{data:function(){return{title:"算法学习：冒泡排序",description:"算法学习：冒泡排序",keywords:"原创,JavaScript,算法",pathname:"algo-bubble-sort",translation:null,create_time:"2016-11-09",prev:{title:"[译] 理解 Node.js 事件循环",pathname:"nodejs-event-loop"},next:{title:"算法学习：选择排序",pathname:"algo-selection-sort"}}}}},_=l(3),component=Object(_.a)(v,function(){var n=this,t=n.$createElement,l=n._self._c||t;return l("post",{attrs:{data:n.data}},[l("p",[n._v("从基础入手。前面学习了"),l("a",{attrs:{href:"../algo-insertion-sort/"}},[n._v("插入排序")]),n._v("和"),l("a",{attrs:{href:"../algo-selection-sort"}},[n._v("选择排序")]),n._v("。")]),n._v(" "),l("p",[n._v("接下来看冒泡排序。")]),n._v(" "),l("p",[n._v("依然假设手上有 N 张扑克牌，记作 cards。")]),n._v(" "),l("p",[n._v("第一步，先比较第 1 张与第 2 张，如果第 1 张比第 2 张大，则将两者调换位置；")]),n._v(" "),l("p",[n._v("第二步，重复上面的方法，比较第 2 张、第 3 张；")]),n._v(" "),l("p",[n._v("……")]),n._v(" "),l("p",[n._v("第 (n - 1) 步，比较第 (n - 1) 张、第 n 张，若第 (n - 1) 张比第 n 张大，则将两者调换位置。")]),n._v(" "),l("p",[n._v("仔细想下，发现没有？这样 (n - 1) 个步骤下来，整个数组中最大数已经被顺利推到最右侧啦！也就是说，现在第 n 个数已经是最大的。这就是冒泡排序叫“冒泡”的原因。")]),n._v(" "),l("p",[n._v("那么接下来，我们只需要对前面的 (n - 1) 个数再进行同样的 (n - 2) 次操作，找到第二大的数放在第 (n - 1) 个位置上。")]),n._v(" "),l("p",[n._v("最后的实现如下：")]),n._v(" "),l("pre",[l("code",{staticClass:"hljs lang-javascript"},[l("span",{staticClass:"hljs-keyword"},[n._v("const")]),n._v(" bubbleSort = "),l("span",{staticClass:"hljs-function"},[n._v("("),l("span",{staticClass:"hljs-params"},[n._v("cards")]),n._v(") =>")]),n._v(" {\n  cards = cards.slice("),l("span",{staticClass:"hljs-number"},[n._v("0")]),n._v(");\n\n  "),l("span",{staticClass:"hljs-keyword"},[n._v("let")]),n._v(" len = cards.length;\n  "),l("span",{staticClass:"hljs-keyword"},[n._v("let")]),n._v(" temp = "),l("span",{staticClass:"hljs-number"},[n._v("0")]),n._v(";\n\n  "),l("span",{staticClass:"hljs-keyword"},[n._v("for")]),n._v(" ("),l("span",{staticClass:"hljs-keyword"},[n._v("let")]),n._v(" i = len - "),l("span",{staticClass:"hljs-number"},[n._v("1")]),n._v("; i >= "),l("span",{staticClass:"hljs-number"},[n._v("0")]),n._v("; i--) {\n\n    "),l("span",{staticClass:"hljs-keyword"},[n._v("for")]),n._v(" ("),l("span",{staticClass:"hljs-keyword"},[n._v("let")]),n._v(" j = "),l("span",{staticClass:"hljs-number"},[n._v("0")]),n._v("; j < len - i; j++) {\n\n      "),l("span",{staticClass:"hljs-keyword"},[n._v("if")]),n._v(" (cards[j] > cards[j + "),l("span",{staticClass:"hljs-number"},[n._v("1")]),n._v("]) {\n        temp = cards[j + "),l("span",{staticClass:"hljs-number"},[n._v("1")]),n._v("];\n        cards[j + "),l("span",{staticClass:"hljs-number"},[n._v("1")]),n._v("] = cards[j];\n        cards[j] = temp;\n      }\n    }\n  }\n\n  "),l("span",{staticClass:"hljs-keyword"},[n._v("return")]),n._v(" cards;\n};")])]),l("p",[n._v("仅仅看循环次数，评估下冒泡排序的复杂度。很简单，因为每次需要 (i - 1) 步的两两对比，因此总的时间是：")]),n._v(" "),l("pre",[l("code",{staticClass:"hljs lang-javascript"},[n._v("(n - "),l("span",{staticClass:"hljs-number"},[n._v("1")]),n._v(") + (n - "),l("span",{staticClass:"hljs-number"},[n._v("2")]),n._v(") + ... + ("),l("span",{staticClass:"hljs-number"},[n._v("2")]),n._v(" - "),l("span",{staticClass:"hljs-number"},[n._v("1")]),n._v(") + ("),l("span",{staticClass:"hljs-number"},[n._v("1")]),n._v(" - "),l("span",{staticClass:"hljs-number"},[n._v("1")]),n._v(") = n * (n - "),l("span",{staticClass:"hljs-number"},[n._v("1")]),n._v(") / "),l("span",{staticClass:"hljs-number"},[n._v("2")])])]),l("p",[n._v("复杂度为 O(n^n)。不过，在最坏的情况下，交换操作也是 O(n^n)，这对数组来说，还是有些可怕。")])])},[],!1,null,null,null);t.default=component.exports}}]);