(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{232:function(t,v,n){"use strict";n.r(v);var _={computed:{data:function(){return{title:"[译] 手把手教你写一个 Javascript 框架：沙箱求值",description:"关于沙箱求值，ES6，Proxy，Symbol，WeakMap",keywords:"翻译,JavaScript,ES6",pathname:"sandbox-code-evaluation",translation:{author:"Bertalan Miklos",social:"https://blog.risingstack.com/author/bertalan/",from:"https://blog.risingstack.com/writing-a-javascript-framework-sandboxed-code-evaluation/"},create_time:"2016-11-18",prev:{title:"[译] 手把手教你写一个 Javascript 框架：项目结构",pathname:"nx-project-structure"},next:{title:"[译] 手把手教你写一个 Javascript 框架：执行调度",pathname:"execution-timing"}}}}},e=n(3),component=Object(e.a)(_,function(){var t=this,v=t.$createElement,n=t._self._c||v;return n("post",{attrs:{data:t.data}},[n("p",[n("strong",[t._v("本文是“编写 JavaScript 框架”系列的第三章。在本章中，我将介绍浏览器中对代码求值的几种不同方式及其存在的问题，也会介绍一种依赖 JavaScript 新特性的方法。")])]),t._v(" "),n("p",[t._v("本系列主要是如何开发一个开源的客户端框架，框架名为 NX。我将在本系列中分享框架编写过程中如何克服遇到的主要困难。对 NX 感兴趣的朋友可以点击 NX 项目"),n("a",{attrs:{href:"http://nx-framework.com/",target:"_blank"}},[t._v("主页")]),t._v("查看。")]),t._v(" "),n("p",[t._v("本系列章节如下：")]),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"/post/nx-project-structure/"}},[t._v("项目结构（Project structuring）")])]),t._v(" "),n("li",[n("a",{attrs:{href:"/post/execution-timing/"}},[t._v("执行调度(Execution timing)")])]),t._v(" "),n("li",[t._v("沙箱求值（本章）")]),t._v(" "),n("li",[n("a",{attrs:{href:"/post/data-bind-dirty-checking"}},[t._v("数据绑定简介")])]),t._v(" "),n("li",[n("a",{attrs:{href:"/post/es6-proxy-data-binding/"}},[t._v("ES6 Proxy 实现数据绑定")])]),t._v(" "),n("li",[t._v("自定义元素")]),t._v(" "),n("li",[t._v("客户端路由")])]),t._v(" "),n("h2",{attrs:{id:"-eval"}},[t._v("邪恶 eval")]),t._v(" "),n("blockquote",[n("p",[n("code",[t._v("eval()")]),t._v(" 函数用来对字符串形式的 JavaScript 代码进行求值。")])]),t._v(" "),n("p",[t._v("常见的代码求值方法是使用 "),n("code",[t._v("eval()")]),t._v(" 函数。通过 "),n("code",[t._v("eval()")]),t._v(" 执行的代码可以访问闭包和全局作用域，所以可能导致"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Code_injection",target:"_blank"}},[t._v("代码注入(code injection)")]),t._v("，正因此 "),n("code",[t._v("eval()")]),t._v(" 成为 JavaScript 中最臭名昭著的特性之一。")]),t._v(" "),n("p",[t._v("抛开上述缺点不说，"),n("code",[t._v("eval()")]),t._v(" 在某些情况下还是很有用的。多数现代前端框架都需要 "),n("code",[t._v("eval()")]),t._v(" 的这种功能，但是往往又因前述问题畏手畏脚。因此出现许多字符串求值方案，在沙箱而非全局作用域中进行操作。沙箱可以阻止代码访问与安全相关的数据，它通常是一个简单对象，用于替换代码中的全局对象。")]),t._v(" "),n("h2",{attrs:{id:"-"}},[t._v("常见做法")]),t._v(" "),n("p",[t._v("替代 "),n("code",[t._v("eval()")]),t._v(" 最常见的方式是彻底重新实现。重新实现的过程由解析（parsing）、解释（interpreting）两步组成。首先由解析器创建"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree",target:"_blank"}},[t._v("抽象语法树")]),t._v("，然后由解释器遍历语法树，将其译为运行在沙箱中的代码。")]),t._v(" "),n("p",[t._v("这种方案使用广泛，但可谓是杀鸡拿了把牛刀。放弃修补 "),n("code",[t._v("eval()")]),t._v("，选择从零开始重写，带来的后果就是，许多 bug 蠢蠢欲动，准备伺机而出。而随着语言的升级更新，也不得不频繁修改源码。")]),t._v(" "),n("h2",{attrs:{id:"-"}},[t._v("另一种思路")]),t._v(" "),n("p",[n("a",{attrs:{href:"http://nx-framework.com",target:"_blank"}},[t._v("NX")]),t._v("  尽可能避免了重新实现代码，采用一个很小的库处理求值，该库使用了一些较可能少为人知的新特性。")]),t._v(" "),n("p",[t._v("这一节逐步介绍这些特性，并使用它们解释用于代码求值的 "),n("a",{attrs:{href:"https://github.com/RisingStack/nx-compile",target:"_blank"}},[t._v("nx-compile")]),t._v(" 库。这个库有一个名为 "),n("code",[t._v("compileCode()")]),t._v(" 的函数，工作方式如下：")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" code = compileCode("),n("span",{staticClass:"hljs-string"},[t._v("'return num1 + num2'")]),t._v(")\n\n"),n("span",{staticClass:"hljs-comment"},[t._v("// 控制台打印 17")]),t._v("\n"),n("span",{staticClass:"hljs-built_in"},[t._v("console")]),t._v(".log(code({"),n("span",{staticClass:"hljs-attr"},[t._v("num1")]),t._v(": "),n("span",{staticClass:"hljs-number"},[t._v("10")]),t._v(", "),n("span",{staticClass:"hljs-attr"},[t._v("num2")]),t._v(": "),n("span",{staticClass:"hljs-number"},[t._v("7")]),t._v("}))\n\n"),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" globalNum = "),n("span",{staticClass:"hljs-number"},[t._v("12")]),t._v("  \n"),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" otherCode = compileCode("),n("span",{staticClass:"hljs-string"},[t._v("'return globalNum'")]),t._v(")\n\n"),n("span",{staticClass:"hljs-comment"},[t._v("// 访问全局作用域被禁止")]),t._v("\n"),n("span",{staticClass:"hljs-comment"},[t._v("// 控制台打印 undefined")]),t._v("\n"),n("span",{staticClass:"hljs-built_in"},[t._v("console")]),t._v(".log(otherCode({"),n("span",{staticClass:"hljs-attr"},[t._v("num1")]),t._v(": "),n("span",{staticClass:"hljs-number"},[t._v("2")]),t._v(", "),n("span",{staticClass:"hljs-attr"},[t._v("num2")]),t._v(": "),n("span",{staticClass:"hljs-number"},[t._v("3")]),t._v("}))")])]),n("p",[t._v("待到本文结束，我们会用不到 20 行的代码实现 "),n("code",[t._v("compileCode()")]),t._v(" 函数。")]),t._v(" "),n("h3",{attrs:{id:"-new-function-"}},[n("code",[t._v("new Function()")])]),t._v(" "),n("blockquote",[n("p",[t._v("Function 构造函数用于创建新的 Function 对象。在 JavaScript 中，所有函数都是 Function 对象。")])]),t._v(" "),n("p",[t._v("Function 构造函数可以达到 "),n("code",[t._v("eval()")]),t._v(" 同样的目的。"),n("code",[t._v("new Function(...args, 'funcBody')")]),t._v(" 对传入的 "),n("code",[t._v("'funcBody'")]),t._v(" 字符进行求值，并返回执行这段代码的函数。"),n("code",[t._v("new Function()")]),t._v(" 与 "),n("code",[t._v("eval()")]),t._v(" 的不同主要体现在以下两方面：")]),t._v(" "),n("ul",[n("li",[n("p",[n("code",[t._v("new Function()")]),t._v(" 方法只会对传入的代码求值一次。调用返回函数时，只会运行代码，而不会重新求值。")])]),t._v(" "),n("li",[n("p",[n("code",[t._v("new Function()")]),t._v(" 方法无法访问闭包中的本地变量；不过还是可以访问全局作用域。")])])]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("compileCode")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("src")]),t._v(") ")]),t._v("{  \n  "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" "),n("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" "),n("span",{staticClass:"hljs-built_in"},[t._v("Function")]),t._v("(src)\n}")])]),n("p",[t._v("对我们来说，"),n("code",[t._v("new Function()")]),t._v(" 要优于 "),n("code",[t._v("eval()")]),t._v("。它性能更好，也更安全。不过要使其完全可用，还需要阻止其访问全局作用域。")]),t._v(" "),n("h3",{attrs:{id:"-with-"}},[n("code",[t._v("with")]),t._v(" 关键词")]),t._v(" "),n("blockquote",[n("p",[n("code",[t._v("with")]),t._v(" 能够扩展声明的作用域链。")])]),t._v(" "),n("p",[t._v("JavaScript 中，"),n("code",[t._v("with")]),t._v(" 关键词较少露面。"),n("code",[t._v("with")]),t._v(" 可以帮我们半沙箱化地执行代码。"),n("code",[t._v("with")]),t._v(" 语句块首先会试着从传递的沙箱对象检索变量，如果没有找到，则会到闭包和全局作用域中寻找。前面说过，"),n("code",[t._v("new Function()")]),t._v(" 能够阻止访问闭包中的变量，故现在只需考虑全局作用域的问题。")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("compileCode")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("src")]),t._v(") ")]),t._v("{\n  src = "),n("span",{staticClass:"hljs-string"},[t._v("'with (sandbox) {'")]),t._v(" + src + "),n("span",{staticClass:"hljs-string"},[t._v("'}'")]),t._v("\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" "),n("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" "),n("span",{staticClass:"hljs-built_in"},[t._v("Function")]),t._v("("),n("span",{staticClass:"hljs-string"},[t._v("'sandbox'")]),t._v(", src)\n}")])]),n("p",[t._v("在内部实现中，"),n("code",[t._v("with")]),t._v(" 使用了 "),n("code",[t._v("in")]),t._v(" 操作。对于语句块中的所有变量访问，都会使用 "),n("code",[t._v("variable in sandbox")]),t._v(" 条件进行判断。若条件为真，则从沙箱对象中读取变量；否则会去全局变量中寻找变量。在 "),n("code",[t._v("with")]),t._v(" 操作过程中，我们可以让 "),n("code",[t._v("variable in sandbox")]),t._v(" 永远返回 true，这样就能阻止访问全局变量。")]),t._v(" "),n("p",[n("img",{directives:[{name:"lazy",rawName:"v-lazy",value:"https://s.ssl.qhres2.com/static/fc3642ce6bdb875f.svg",expression:"`https://s.ssl.qhres2.com/static/fc3642ce6bdb875f.svg`"}],attrs:{alt:"Sandboxed code evaluation: Simple 'with' statement"}})]),t._v(" "),n("h3",{attrs:{id:"es6-proxy"}},[t._v("ES6 Proxy")]),t._v(" "),n("blockquote",[n("p",[t._v("Proxy 对象用于自定义 Object 的一些基本操作，如属性读取、赋值等行为。")])]),t._v(" "),n("p",[t._v("ES6 "),n("code",[t._v("Proxy")]),t._v(" 封装对象，并定义一些 trap 函数，这些函数可以拦截该对象的基本操作行为。操作对象时，就会调用相应的 trap 函数。使用 "),n("code",[t._v("Proxy")]),t._v(" 封装沙箱对象，定义一个 "),n("code",[t._v("has")]),t._v(" 操作 trap，即可覆盖 "),n("code",[t._v("in")]),t._v(" 操作符的默认行为。")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("compileCode")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("src")]),t._v(") ")]),t._v("{\n  src = "),n("span",{staticClass:"hljs-string"},[t._v("'with (sandbox) {'")]),t._v(" + src + "),n("span",{staticClass:"hljs-string"},[t._v("'}'")]),t._v("\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" code = "),n("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" "),n("span",{staticClass:"hljs-built_in"},[t._v("Function")]),t._v("("),n("span",{staticClass:"hljs-string"},[t._v("'sandbox'")]),t._v(", src)\n\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" "),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("sandbox")]),t._v(") ")]),t._v("{\n    "),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" sandboxProxy = "),n("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" "),n("span",{staticClass:"hljs-built_in"},[t._v("Proxy")]),t._v("(sandbox, {has})\n    "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" code(sandboxProxy)\n  }\n}\n\n"),n("span",{staticClass:"hljs-comment"},[t._v("// 用于拦截对 sandboxProxy 的 'in' 操作")]),t._v("\n"),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("has")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("target, key")]),t._v(") ")]),t._v("{\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" "),n("span",{staticClass:"hljs-literal"},[t._v("true")]),t._v("\n}")])]),n("p",[t._v("上面的代码耍了 "),n("code",[t._v("with")]),t._v(" 代码块一把。"),n("code",[t._v("variable in sandbox")]),t._v(" 将永远为真，因为 "),n("code",[t._v("has")]),t._v(" trap 函数总是返回 true。"),n("code",[t._v("width")]),t._v(" 代码块中的代码永远无法访问全局对象。")]),t._v(" "),n("p",[n("img",{directives:[{name:"lazy",rawName:"v-lazy",value:"https://s.ssl.qhres2.com/static/d9e40b9163d31b54.svg",expression:"`https://s.ssl.qhres2.com/static/d9e40b9163d31b54.svg`"}],attrs:{alt:"Sandboxed code evaluation: 'with' statement and proxies"}})]),t._v(" "),n("h3",{attrs:{id:"-symbol-unscopables-"}},[n("code",[t._v("Symbol.unscopables")])]),t._v(" "),n("blockquote",[n("p",[t._v("Symbol 是一种唯一的、不可变的数据类型，可用作对象属性标识符。")])]),t._v(" "),n("p",[n("code",[t._v("Symbol.unscopables")]),t._v(" 是一个驰名 symbol（"),n("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol",target:"_blank"}},[t._v("Well-known symbol")]),t._v("）。所谓“驰名 symbol”，实际上是一些内置 JavaScript "),n("code",[t._v("Symbol")]),t._v("，代表某些内部语言行为。驰名 symbol 可以用于添加或重写一些行为，如数据的迭代、基本类型转换。")]),t._v(" "),n("blockquote",[n("p",[t._v("Symbol.unscopables 用于指定对象的一些固有和继承属性，这些属性被排除在 "),n("code",[t._v("with")]),t._v(" 所绑定的环境之外无法读取。")])]),t._v(" "),n("p",[n("code",[t._v("Symbol.unscopables")]),t._v(" 用于定义对象的 unscopable 属性（译者：不译，请自行领会）。"),n("code",[t._v("with")]),t._v(" 声明中的沙箱对象的 unscopable 属性无法读取，这些属性会从闭包、全局作用域中读取。通常极少需要用到 "),n("code",[t._v("Symbol.unscopables")]),t._v("。在"),n("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/unscopables",target:"_blank"}},[t._v("这里")]),t._v("可以看到引入 "),n("code",[t._v("Symbol.unscopables")]),t._v(" 的原因。")]),t._v(" "),n("p",[n("img",{directives:[{name:"lazy",rawName:"v-lazy",value:"https://s.ssl.qhres2.com/static/f8e5bdb1ebf22a58.svg",expression:"`https://s.ssl.qhres2.com/static/f8e5bdb1ebf22a58.svg`"}],attrs:{alt:"Sandboxed code evaluation: 'with' statement and proxies. A security issue."}})]),t._v(" "),n("p",[t._v("我们为沙箱对象 proxy 添加一个"),n("code",[t._v("get")]),t._v(" trap 函数，拦截检索 "),n("code",[t._v("Symbol.unscopables")]),t._v(" 属性的行为，总是返回 undefined。这样会骗到 "),n("code",[t._v("with")]),t._v(" 代码块，使其认为沙箱对象没有任何 unscopable 属性。")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("compileCode")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("src")]),t._v(") ")]),t._v("{\n  src = "),n("span",{staticClass:"hljs-string"},[t._v("'with (sandbox) {'")]),t._v(" + src + "),n("span",{staticClass:"hljs-string"},[t._v("'}'")]),t._v("\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" code = "),n("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" "),n("span",{staticClass:"hljs-built_in"},[t._v("Function")]),t._v("("),n("span",{staticClass:"hljs-string"},[t._v("'sandbox'")]),t._v(", src)\n\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" "),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("sandbox")]),t._v(") ")]),t._v("{\n    "),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" sandboxProxy = "),n("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" "),n("span",{staticClass:"hljs-built_in"},[t._v("Proxy")]),t._v("(sandbox, {has, get})\n    "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" code(sandboxProxy)\n  }\n}\n\n"),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("has")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("target, key")]),t._v(") ")]),t._v("{\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" "),n("span",{staticClass:"hljs-literal"},[t._v("true")]),t._v("\n}\n\n"),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("get")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("target, key")]),t._v(") ")]),t._v("{\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("if")]),t._v(" (key === "),n("span",{staticClass:"hljs-built_in"},[t._v("Symbol")]),t._v(".unscopables) "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" "),n("span",{staticClass:"hljs-literal"},[t._v("undefined")]),t._v("\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" target[key]\n}")])]),n("p",[n("img",{directives:[{name:"lazy",rawName:"v-lazy",value:"https://s.ssl.qhres2.com/static/f2ac13b8fe932334.svg",expression:"`https://s.ssl.qhres2.com/static/f2ac13b8fe932334.svg`"}],attrs:{alt:"Sandboxed code evaluation: 'with' statement and proxies. Has and get traps."}})]),t._v(" "),n("h3",{attrs:{id:"-weakmap-"}},[t._v("使用 WeakMap 进行缓存")]),t._v(" "),n("p",[t._v("代码现在是安全的，但性能还有可提升之处：可以看到，每次调用返回的函数时都会新建一个 "),n("code",[t._v("Proxy")]),t._v("。通过缓存可以避免该问题，每次调用时，若沙箱对象相同，则可以使用同一个 "),n("code",[t._v("Proxy")]),t._v(" 对象。")]),t._v(" "),n("p",[t._v("Proxy 对象与沙箱对象一一对应，故可以单纯地将其作为沙箱对象的一个属性。不过，这可能会对外暴露代码实现细节。另外，若使用的是 "),n("code",[t._v("Object.freeze()")]),t._v(" 冻结之后的不可变沙箱对象也不行。所以采用 "),n("code",[t._v("WeakMap")]),t._v(" 才是更好的选择。")]),t._v(" "),n("blockquote",[n("p",[t._v("WeakMap 对象是一个键值对集合。键为弱引用，必须是对象；值可以为任意类型。")])]),t._v(" "),n("p",[n("code",[t._v("WeakMap")]),t._v(" 可在不直接扩展对象属性的情况下为该对象附加数据。通过 "),n("code",[t._v("WeakMap")]),t._v(" 间接为沙箱对象添加缓存的 "),n("code",[t._v("Proxy")]),t._v("。")]),t._v(" "),n("pre",[n("code",{staticClass:"hljs lang-javascript"},[n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" sandboxProxies = "),n("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" "),n("span",{staticClass:"hljs-built_in"},[t._v("WeakMap")]),t._v("()\n\n"),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("compileCode")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("src")]),t._v(") ")]),t._v("{\n  src = "),n("span",{staticClass:"hljs-string"},[t._v("'with (sandbox) {'")]),t._v(" + src + "),n("span",{staticClass:"hljs-string"},[t._v("'}'")]),t._v("\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" code = "),n("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" "),n("span",{staticClass:"hljs-built_in"},[t._v("Function")]),t._v("("),n("span",{staticClass:"hljs-string"},[t._v("'sandbox'")]),t._v(", src)\n\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" "),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("sandbox")]),t._v(") ")]),t._v("{\n    "),n("span",{staticClass:"hljs-keyword"},[t._v("if")]),t._v(" (!sandboxProxies.has(sandbox)) {\n      "),n("span",{staticClass:"hljs-keyword"},[t._v("const")]),t._v(" sandboxProxy = "),n("span",{staticClass:"hljs-keyword"},[t._v("new")]),t._v(" "),n("span",{staticClass:"hljs-built_in"},[t._v("Proxy")]),t._v("(sandbox, {has, get})\n      sandboxProxies.set(sandbox, sandboxProxy)\n    }\n    "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" code(sandboxProxies.get(sandbox))\n  }\n}\n\n"),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("has")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("target, key")]),t._v(") ")]),t._v("{\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" "),n("span",{staticClass:"hljs-literal"},[t._v("true")]),t._v("\n}\n\n"),n("span",{staticClass:"hljs-function"},[n("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),n("span",{staticClass:"hljs-title"},[t._v("get")]),t._v(" ("),n("span",{staticClass:"hljs-params"},[t._v("target, key")]),t._v(") ")]),t._v("{\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("if")]),t._v(" (key === "),n("span",{staticClass:"hljs-built_in"},[t._v("Symbol")]),t._v(".unscopables) "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" "),n("span",{staticClass:"hljs-literal"},[t._v("undefined")]),t._v("\n  "),n("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" target[key]\n}")])]),n("p",[t._v("这样一来，只会为每个沙箱对象新建一次 "),n("code",[t._v("Proxy")]),t._v(" 对象。")]),t._v(" "),n("h3",{attrs:{id:"-"}},[t._v("最后一点")]),t._v(" "),n("p",[t._v("上面的 "),n("code",[t._v("compileCode()")]),t._v(" 例子仅 19 行代码，已经是一个可以工作的沙箱代码求值工具。如果有兴趣看看 nx-compile 的完整代码，可以访问 "),n("a",{attrs:{href:"https://github.com/RisingStack/nx-compile",target:"_blank"}},[t._v("Github 仓库")]),t._v("。")]),t._v(" "),n("p",[t._v("除解释代码求值外，本章的主要目的是展示一些 ES6 新特性，用它们替代原有方式。贯穿整个例子，我试图展示了 "),n("code",[t._v("Proxy")]),t._v(" 和 "),n("code",[t._v("Symbol")]),t._v(" 的强大力量。")]),t._v(" "),n("h2",{attrs:{id:"-"}},[t._v("写在最后")]),t._v(" "),n("p",[t._v("如果对 NX 框架感兴趣，请访问 "),n("a",{attrs:{href:"http://nx-framework.com/",target:"_blank"}},[t._v("主页")]),t._v("。胆大的读者还可以在 Github 上查看 "),n("a",{attrs:{href:"https://github.com/RisingStack/nx-framework",target:"_blank"}},[t._v("NX 源码")]),t._v(" 和 "),n("a",{attrs:{href:"https://github.com/RisingStack/nx-observe",target:"_blank"}},[t._v("nx-observe 源码")]),t._v("。")]),t._v(" "),n("p",[t._v("希望你喜欢这篇文章。下一章我们将讨论 "),n("a",{attrs:{href:"https://blog.risingstack.com/writing-a-javascript-framework-data-binding-dirty-checking/",target:"_blank"}},[t._v("数据绑定")]),t._v("。")])])},[],!1,null,null,null);v.default=component.exports}}]);