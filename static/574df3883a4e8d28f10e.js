(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{227:function(t,n,_){"use strict";_.r(n);var v={computed:{data:function(){return{title:"Facebook 开源代码优化工具 Prepack",description:"Facebook 开源代码优化工具 Prepack",keywords:"JavaScript",pathname:"prepack",translation:null,create_time:"2017-05-04",prev:{title:"[译] 浏览器中的 ES6 module 实现",pathname:"es-modules-in-browsers"},next:{title:"[译] 内容加速黑科技趣谈",pathname:"fun-hacks-faster-content"}}}}},e=_(3),component=Object(e.a)(v,function(){var t=this,n=t.$createElement,_=t._self._c||n;return _("post",{attrs:{data:t.data}},[_("p",[t._v("Fackbook 又搞了个大新闻！")]),t._v(" "),_("p",[t._v("今天一早，朋友圈被一个名为 Prepack 的工具刷爆了。")]),t._v(" "),_("p",[t._v("周刊君很好奇地看了下官网（"),_("a",{attrs:{href:"https://prepack.io/",target:"_blank"}},[t._v("prepack.io")]),t._v("），这么厉害的工具，有必要第一时间向大家介绍一下（还能不能好好过个青年节了）。")]),t._v(" "),_("p",[t._v("看 “Prepack” 这个名字就能大概知道，它的作用，肯定是在发布前（“pre”）对代码动了些什么手脚。官网介绍 Prepack 是“一个使 JavaScript 跑得更快的工具”。那么它到底做了些什么厉害的事情呢？")]),t._v(" "),_("p",[t._v("根据官网首页信息，Prepack “能够消除那些可以本可以在编译（compile）阶段完成的运行时计算”，将代码中的某些部分替换为一系列赋值语句，这样一来就可以省去很多中间计算和对象的分配工作。")]),t._v(" "),_("h3",{attrs:{id:"-"}},[t._v("官方示例")]),t._v(" "),_("p",[t._v("下面是 Prepack 官网给出的一个例子：")]),t._v(" "),_("pre",[_("code",{staticClass:"hljs lang-javascript"},[t._v("("),_("span",{staticClass:"hljs-function"},[_("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" ("),_("span",{staticClass:"hljs-params"}),t._v(") ")]),t._v("{\n  "),_("span",{staticClass:"hljs-keyword"},[t._v("var")]),t._v(" self = "),_("span",{staticClass:"hljs-keyword"},[t._v("this")]),t._v(";\n  ["),_("span",{staticClass:"hljs-string"},[t._v("'A'")]),t._v(", "),_("span",{staticClass:"hljs-string"},[t._v("'B'")]),t._v(", "),_("span",{staticClass:"hljs-number"},[t._v("42")]),t._v("].forEach("),_("span",{staticClass:"hljs-function"},[_("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v("("),_("span",{staticClass:"hljs-params"},[t._v("x")]),t._v(") ")]),t._v("{\n    "),_("span",{staticClass:"hljs-keyword"},[t._v("var")]),t._v(" name = "),_("span",{staticClass:"hljs-string"},[t._v("'_'")]),t._v(" + x.toString()["),_("span",{staticClass:"hljs-number"},[t._v("0")]),t._v("].toLowerCase();\n    "),_("span",{staticClass:"hljs-keyword"},[t._v("var")]),t._v(" y = "),_("span",{staticClass:"hljs-built_in"},[t._v("parseInt")]),t._v("(x);\n    self[name] = y ? y : x;\n  });\n})();")])]),_("p",[t._v("经过 Prepack 的处理，上面这段代码变成了下面这样：")]),t._v(" "),_("pre",[_("code",{staticClass:"hljs lang-javascript"},[t._v("("),_("span",{staticClass:"hljs-function"},[_("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" ("),_("span",{staticClass:"hljs-params"}),t._v(") ")]),t._v("{\n  _a = "),_("span",{staticClass:"hljs-string"},[t._v('"A"')]),t._v(";\n  _b = "),_("span",{staticClass:"hljs-string"},[t._v('"B"')]),t._v(";\n  _4 = "),_("span",{staticClass:"hljs-number"},[t._v("42")]),t._v(";\n})();")])]),_("p",[t._v("原来的 "),_("code",[t._v(".forEach")]),t._v(" 调用没有了，一系列的中间转换过程也不见了。借用官网的说法，“多数的计算都在 Prepack 编译时进行了预初始化”。")]),t._v(" "),_("p",[t._v("再举一个 Fibonacci 的例子：")]),t._v(" "),_("pre",[_("code",{staticClass:"hljs lang-javascript"},[_("span",{staticClass:"hljs-comment"},[t._v("// 处理前")]),t._v("\n("),_("span",{staticClass:"hljs-function"},[_("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" ("),_("span",{staticClass:"hljs-params"}),t._v(") ")]),t._v("{\n  "),_("span",{staticClass:"hljs-function"},[_("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" "),_("span",{staticClass:"hljs-title"},[t._v("fibonacci")]),t._v("("),_("span",{staticClass:"hljs-params"},[t._v("x")]),t._v(") ")]),t._v("{\n    "),_("span",{staticClass:"hljs-keyword"},[t._v("return")]),t._v(" x <= "),_("span",{staticClass:"hljs-number"},[t._v("1")]),t._v(" ? x : fibonacci(x - "),_("span",{staticClass:"hljs-number"},[t._v("1")]),t._v(") + fibonacci(x - "),_("span",{staticClass:"hljs-number"},[t._v("2")]),t._v(");\n  }\n  global.x = fibonacci("),_("span",{staticClass:"hljs-number"},[t._v("23")]),t._v(");\n})();\n\n"),_("span",{staticClass:"hljs-comment"},[t._v("// 处理后")]),t._v("\n("),_("span",{staticClass:"hljs-function"},[_("span",{staticClass:"hljs-keyword"},[t._v("function")]),t._v(" ("),_("span",{staticClass:"hljs-params"}),t._v(") ")]),t._v("{\n  x = "),_("span",{staticClass:"hljs-number"},[t._v("28657")]),t._v(";\n})();")])]),_("h3",{attrs:{id:"-"}},[t._v("工作机制")]),t._v(" "),_("p",[t._v("据官网介绍，Prepack 的实现依赖以下几个方面：")]),t._v(" "),_("h4",{attrs:{id:"1-ast-"}},[t._v("1. AST（抽象语法树）")]),t._v(" "),_("p",[t._v("Prepack 是在 AST 这一层级对代码进行操作的。通过 Babel 来解析源码，并生成优化后的代码。关于 Babel 与 AST，周刊君推荐两篇文章：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("《"),_("a",{attrs:{href:"https://mp.weixin.qq.com/s/fFQUBeg332gdU8yNddauxQ",target:"_blank"}},[t._v("Babel for ES6? And Beyond!")]),t._v("》")])]),t._v(" "),_("li",[_("p",[t._v("《"),_("a",{attrs:{href:"http://www.zcfy.cc/article/347",target:"_blank"}},[t._v("通过开发 Babel 插件理解抽象语法树（AST）")]),t._v("》")])])]),t._v(" "),_("h4",{attrs:{id:"2-concrete-execution-"}},[t._v("2. 具体执行（Concrete Execution）")]),t._v(" "),_("p",[t._v("Prepack 的核心部分是“一个大致兼容 ECMAScript 5 的编译器”（an almost ECMAScript 5 compatible interpreter），而这个编译器是通过 JavaScript 实现的。这个编译器可以追踪、撤销包括对象变化在内的所有的操作。这样一来就能进行推理性的优化（speculative optimizations）。")]),t._v(" "),_("h4",{attrs:{id:"3-symbolic-execution-"}},[t._v("3. 符号执行（Symbolic Execution）")]),t._v(" "),_("p",[t._v("除了计算具体值，Prepack 的编译器还可以操作抽象值，而这些抽象值通常都来自于代码与环境的交互。如 "),_("code",[t._v("Date.now")]),t._v(" 所返回的就是抽象值。此外，根据官网首页的描述，还可以通过 "),_("code",[t._v("__abstract()")]),t._v(" 这样的辅助工具函数，手动插入抽象值。Prepack 会追踪发生在抽象值之上的操作，如果有分支情况，则会对所有可能性进行探查。")]),t._v(" "),_("p",[t._v("官网介绍说，“因此，Prepack 为 JavaScript 实现了一套符号执行引擎”。为了方便大家理解，周刊君特地引用了"),_("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C",target:"_blank"}},[t._v("维基百科")]),t._v("上的一段话：")]),t._v(" "),_("blockquote",[_("p",[t._v("符号执行 （Symbolic Execution）是一种程序分析技术。其可以通过分析程序来得到让特定代码区域执行的输入。使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。")])]),t._v(" "),_("h4",{attrs:{id:"4-abstract-interpretation-"}},[t._v("4. 抽象解释（Abstract Interpretation）")]),t._v(" "),_("p",[t._v("官网的描述有点复杂。关于抽象解释，请移步"),_("a",{attrs:{href:"https://en.wikipedia.org/wiki/Abstract_interpretation",target:"_blank"}},[t._v("维基百科")]),t._v("。有兴趣的可以去官网阅读原文。")]),t._v(" "),_("h4",{attrs:{id:"5-heap-serialization-"}},[t._v("5. 堆序列化（Heap Serialization）")]),t._v(" "),_("p",[t._v("初始化阶段结束时，Prepack 会捕获最终的堆。按顺序遍历堆，生成新的代码，创建、链接堆中的可及对象。")]),t._v(" "),_("p",[t._v("如前所述，堆中的一些值可能是对抽象值进行计算的结果。Prepack 将会根据这些值生成执行计算的代码，其计算过程与源程序相同。")]),t._v(" "),_("h3",{attrs:{id:"-"}},[t._v("环境很重要！")]),t._v(" "),_("p",[t._v("需要注意的是，Prepack 并未完整模拟浏览器、Node 环境，Prepack 对 "),_("code",[t._v("document")]),t._v(" 和 "),_("code",[t._v("window")]),t._v(" 并没有多少了解。对这样一些属性求值的时候，将会得到 "),_("code",[t._v("undefined")]),t._v("。如果需要在这样一些地方使用 Prepack，必须通过一些工具函数实现。")]),t._v(" "),_("h3",{attrs:{id:"-"}},[t._v("如何尝鲜")]),t._v(" "),_("pre",[_("code",{staticClass:"hljs lang-bash"},[_("span",{staticClass:"hljs-comment"},[t._v("# 安装")]),t._v("\nnpm install -g prepack\n\n"),_("span",{staticClass:"hljs-comment"},[t._v("# 处理文件，并打印到控制台")]),t._v("\nprepack script.js\n\n"),_("span",{staticClass:"hljs-comment"},[t._v("# 处理文件，并输出到新文件")]),t._v("\nprepack script.js --out script-processed.js")])]),_("p",[t._v("除了上面的基本用法之外，还支持如 sourceMap 等更多选项。这里就不一一介绍了。")]),t._v(" "),_("h3",{attrs:{id:"-"}},[t._v("当前支持情况")]),t._v(" "),_("p",[t._v("此外，官方介绍称，"),_("strong",[t._v("“Prepack 目前仍处于早期开发阶段，尚未做好投入生产环境的准备”")]),t._v("。不过，还是响应 Prepack 的号召吧，“try it out, give feedback, and help fix bugs”。")]),t._v(" "),_("p",[t._v("想要进一步关于该项目的发展计划，可以访问官网首页的 "),_("a",{attrs:{href:"https://prepack.io/",target:"_blank"}},[t._v("Roadmap")]),t._v(" 部分。")]),t._v(" "),_("h3",{attrs:{id:"-"}},[t._v("相关技术")]),t._v(" "),_("p",[t._v("Closure Compiler 同样会对 JavaScript 代码进行优化。Prepack 比 Closure Compiler 走得更远的地方在于执行了初始化阶段的全局代码，展开循环、递归。官网的一个说法是，“Prepack 着眼于运行时性能，而 Closure Compiler 的重点在于代码体积”。")])])},[],!1,null,null,null);n.default=component.exports}}]);